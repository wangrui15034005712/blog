<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>去年夏天</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://lastsummer.top/blog/"/>
  <updated>2021-03-25T09:29:20.958Z</updated>
  <id>https://lastsummer.top/blog/</id>
  
  <author>
    <name>Wang Rui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Long类型返回前端损失精度</title>
    <link href="https://lastsummer.top/blog/2021/03/25/Long%E7%B1%BB%E5%9E%8B%E8%BF%94%E5%9B%9E%E5%89%8D%E7%AB%AF%E6%8D%9F%E5%A4%B1%E7%B2%BE%E5%BA%A6/"/>
    <id>https://lastsummer.top/blog/2021/03/25/Long类型返回前端损失精度/</id>
    <published>2021-03-25T09:19:00.000Z</published>
    <updated>2021-03-25T09:29:20.958Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JavaScript的Number类型最大长度16位置，超过数值0补齐，四舍五入。"><a href="#JavaScript的Number类型最大长度16位置，超过数值0补齐，四舍五入。" class="headerlink" title="JavaScript的Number类型最大长度16位置，超过数值0补齐，四舍五入。"></a>JavaScript的Number类型最大长度16位置，超过数值0补齐，四舍五入。</h4><a id="more"></a><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JSONField(serializeUsing= ToStringSerializer.class)</span><br><span class="line">private Long id;</span><br></pre></td></tr></table></figure><h3 id="自定义ObjectMapper"><a href="#自定义ObjectMapper" class="headerlink" title="自定义ObjectMapper"></a>自定义ObjectMapper</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@JsonComponent</span><br><span class="line">public class JsonSerializerManage &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) &#123;</span><br><span class="line">        ObjectMapper objectMapper = builder.createXmlMapper(false).build();</span><br><span class="line">        //忽略value为null 时 key的输出</span><br><span class="line">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">        /**</span><br><span class="line">         * 序列换成json时,将所有的long变成string</span><br><span class="line">         * 因为js中得数字类型不能包含所有的java long值</span><br><span class="line">         */</span><br><span class="line">        SimpleModule module = new SimpleModule();</span><br><span class="line">        module.addSerializer(Long.class, ToStringSerializer.instance);</span><br><span class="line">        module.addSerializer(Long.TYPE, ToStringSerializer.instance);</span><br><span class="line">        objectMapper.registerModule(module);</span><br><span class="line">        return objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义全局转换器"><a href="#自定义全局转换器" class="headerlink" title="自定义全局转换器"></a>自定义全局转换器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 解决主键Long类型返回给页面时，页面精度丢失的问题,时间格式化返回</span><br><span class="line">     * @param converters</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class="line">        FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();</span><br><span class="line">        //格式化json数据格式</span><br><span class="line">        FastJsonConfig fastJsonConfig = new FastJsonConfig();</span><br><span class="line">        //序列化时避免精度丢失，转换为字符串</span><br><span class="line">        SerializeConfig serializeConfig = SerializeConfig.globalInstance;</span><br><span class="line">        serializeConfig.put(BigInteger.class, ToStringSerializer.instance);</span><br><span class="line">        serializeConfig.put(Long.class, ToStringSerializer.instance);</span><br><span class="line">        serializeConfig.put(Long.TYPE, ToStringSerializer.instance);</span><br><span class="line">        fastJsonConfig.setSerializeConfig(serializeConfig);</span><br><span class="line">        fastJsonConfig.setDateFormat(&quot;yyyy-HH-dd HH:mm:ss&quot;);</span><br><span class="line">        fastConverter.setFastJsonConfig(fastJsonConfig);</span><br><span class="line">        List&lt;MediaType&gt; fastMediaTypes = new ArrayList&lt;&gt;();</span><br><span class="line">        fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8);</span><br><span class="line">        fastMediaTypes.add(MediaType.APPLICATION_JSON);</span><br><span class="line">        fastConverter.setSupportedMediaTypes(fastMediaTypes);</span><br><span class="line">        converters.add(0,fastConverter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JavaScript的Number类型最大长度16位置，超过数值0补齐，四舍五入。&quot;&gt;&lt;a href=&quot;#JavaScript的Number类型最大长度16位置，超过数值0补齐，四舍五入。&quot; class=&quot;headerlink&quot; title=&quot;JavaScript的Number类型最大长度16位置，超过数值0补齐，四舍五入。&quot;&gt;&lt;/a&gt;JavaScript的Number类型最大长度16位置，超过数值0补齐，四舍五入。&lt;/h4&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="https://lastsummer.top/blog/2021/02/24/SQL%E4%BC%98%E5%8C%96/"/>
    <id>https://lastsummer.top/blog/2021/02/24/SQL优化/</id>
    <published>2021-02-24T09:12:30.000Z</published>
    <updated>2021-03-05T08:13:21.633Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><a id="more"></a><p>1、SQL语句不要使用*，务必指明字段名称<br>2、当只需要一条数据的时候，使用limit 1<br>3、通过explain分析低效率的SQL<br>4、如果排序字段没有用到索引，就尽量少排序<br>5、in和exists、not in和not exists区别<br>6、使用合理的分页方式以提高分页的效率<br>7、避免在where子句中对字段进行null值判断，对于null的判断会导致引擎放弃使用索引而进行全表扫描<br>8、不建议使用%前缀模糊查询，会导致索引失效而进行全表扫描<br>9、避免隐式类型转换（传入的参数和字段类型不一致）<br>10、对于联合索引来说，要遵守最左前缀法则<br>11、必要时可以使用force index来强制查询走某个索引<br>12、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引<br>13、应尽量避免在 where 子句中使用<b>!=、&lt;&gt;、or</b>操作符，否则将引擎放弃使用索引而进行全表扫描<br>14、应尽量避免在 where 子句中对字段进行<b>表达式、函数</b>操作，否则将引擎放弃使用索引而进行全表扫描<br>15、并不是所有索引对查询都有效，当索引列有大量数据重复时（男、女），SQL查询可能不会去利用索引<br>16、一个表的索引数最好不要超过6个<br>17、尽量使用数字型字段，降低查询和连接的性能、增加存储开销<br>18、表的设计合理化，符合三大范式、恰当使用索引<br>19、where提代having，having是在结果集后再过滤总计排序<br>20、使用内置函数提高sql效率<br>21、删除重复数据rowid<br>22、sql语句大写<br>23、使用别名<br>24、truncate提代delete<br>25、较少对表的查询、较少数据库访问、整合无关联简单的数据库访问<br>26、把能排除大量数据的条件写最右边，连接条件写where左边<br>27、sql自右向左解析，把基础表放最右边或者关系表</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SQL优化&quot;&gt;&lt;a href=&quot;#SQL优化&quot; class=&quot;headerlink&quot; title=&quot;SQL优化&quot;&gt;&lt;/a&gt;SQL优化&lt;/h3&gt;
    
    </summary>
    
      <category term="SQL" scheme="https://lastsummer.top/blog/categories/SQL/"/>
    
    
      <category term="SQL" scheme="https://lastsummer.top/blog/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>雪花算法</title>
    <link href="https://lastsummer.top/blog/2020/05/13/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
    <id>https://lastsummer.top/blog/2020/05/13/雪花算法/</id>
    <published>2020-05-13T07:02:13.000Z</published>
    <updated>2020-05-16T05:02:42.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="snowflake-雪花算法"><a href="#snowflake-雪花算法" class="headerlink" title="snowflake 雪花算法"></a>snowflake 雪花算法</h3><p>Twitter_Snowflake<br>SnowFlake的结构如下(每部分用-分开):<br>0-0000000000 0000000000 0000000000 0000000000 0-00000-00000-000000000000<a id="more"></a><br>1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0<br>41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L <em> 60 </em> 60 <em> 24 </em> 365) = 6910位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId<br>12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号加起来刚好64位，为一个Long型<br>5位datacenterId 多服务负载均衡<br>5位workerId 多机器负载均衡<br>SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。</p><h3 id="snowflake-特性"><a href="#snowflake-特性" class="headerlink" title="snowflake 特性"></a>snowflake 特性</h3><p>唯一ID可以标识数据的唯一性，在分布式系统中生成唯一ID的方案有很多，常见的方式大概有以下三种：<br>1、依赖数据库，使用如MySQL自增列或Oracle序列等。<br>2、UUID随机数<br>3、snowflake雪花算法<br>采用数据库自增序列：<br>1、读写分离时，只有主节点可以进行写操作，可能有单点故障的风险<br>2、分表分库，数据迁移合并等比较麻烦<br>UUID随机数：<br>1、采用无意义字符串，没有排序<br>2、UUID使用字符串形式存储，数据量大时查询效率比较低<br>snowflake 算法<br>1、自增（Long）64bit 19数字的数值<br>2、有序<br>3、适合分布式场景</p><h3 id="snowflake-源码"><a href="#snowflake-源码" class="headerlink" title="snowflake 源码"></a>snowflake 源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">public class IdWorker &#123;</span><br><span class="line"></span><br><span class="line">    //下面两个每个5位，加起来就是10位的工作机器id</span><br><span class="line">    private long workerId;    //工作id</span><br><span class="line">    private long datacenterId;   //数据id</span><br><span class="line">    //12位的序列号</span><br><span class="line">    private long sequence;</span><br><span class="line"></span><br><span class="line">    public IdWorker(long workerId, long datacenterId, long sequence) &#123;</span><br><span class="line">        // sanity check for workerId</span><br><span class="line">        if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;,</span><br><span class="line">                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        this.workerId = workerId;</span><br><span class="line">        this.datacenterId = datacenterId;</span><br><span class="line">        this.sequence = sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始时间戳</span><br><span class="line">    private long twepoch = 1288834974657L;</span><br><span class="line"></span><br><span class="line">    //长度为5位</span><br><span class="line">    private long workerIdBits = 5L;</span><br><span class="line">    private long datacenterIdBits = 5L;</span><br><span class="line">    //最大值</span><br><span class="line">    private long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);</span><br><span class="line">    private long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);</span><br><span class="line">    //序列号id长度</span><br><span class="line">    private long sequenceBits = 12L;</span><br><span class="line">    //序列号最大值</span><br><span class="line">    private long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    //工作id需要左移的位数，12位</span><br><span class="line">    private long workerIdShift = sequenceBits;</span><br><span class="line">    //数据id需要左移位数 12+5=17位</span><br><span class="line">    private long datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">    //时间戳需要左移位数 12+5+5=22位</span><br><span class="line">    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    //上次时间戳，初始值为负数</span><br><span class="line">    private long lastTimestamp = -1L;</span><br><span class="line"></span><br><span class="line">    //下一个ID生成算法</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        //获取当前时间戳如果小于上次时间戳，则表示时间戳获取出现异常</span><br><span class="line">        if (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            System.err.printf(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp);</span><br><span class="line">            throw new RuntimeException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;,</span><br><span class="line">                    lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取当前时间戳如果等于上次时间戳（同一毫秒内），则在序列号加一；否则序列号赋值为0，从0开始。</span><br><span class="line">        if (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + 1) &amp; sequenceMask;</span><br><span class="line">            if (sequence == 0) &#123;</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sequence = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将上次时间戳值刷新</span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 返回结果：</span><br><span class="line">         * (timestamp - twepoch) &lt;&lt; timestampLeftShift) 表示将时间戳减去初始时间戳，再左移相应位数</span><br><span class="line">         * (datacenterId &lt;&lt; datacenterIdShift) 表示将数据id左移相应位数</span><br><span class="line">         * (workerId &lt;&lt; workerIdShift) 表示将工作id左移相应位数</span><br><span class="line">         * | 是按位或运算符，例如：x | y，只有当x，y都为0的时候结果才为0，其它情况结果都为1。</span><br><span class="line">         * 因为个部分只有相应位上的值有意义，其它位上都是0，所以将各部分的值进行 | 运算就能得到最终拼接好的id</span><br><span class="line">         */</span><br><span class="line">        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">                (datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">                (workerId &lt;&lt; workerIdShift) |</span><br><span class="line">                sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取时间戳，并与上次时间戳比较</span><br><span class="line">    private long tilNextMillis(long lastTimestamp) &#123;</span><br><span class="line">        long timestamp = timeGen();</span><br><span class="line">        while (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        return timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取系统时间戳</span><br><span class="line">    private long timeGen() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //---------------测试---------------</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IdWorker worker = new IdWorker(1, 1, 0);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            System.out.println(worker.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考博客：<a href="https://www.jianshu.com/p/d3881a6a895e" target="_blank" rel="noopener">ID号生成 雪花算法</a><br>参考博客：<a href="https://www.cnblogs.com/relucent/p/4955340.html" target="_blank" rel="noopener">Twitter的分布式自增ID算法snowflake (Java版)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;snowflake-雪花算法&quot;&gt;&lt;a href=&quot;#snowflake-雪花算法&quot; class=&quot;headerlink&quot; title=&quot;snowflake 雪花算法&quot;&gt;&lt;/a&gt;snowflake 雪花算法&lt;/h3&gt;&lt;p&gt;Twitter_Snowflake&lt;br&gt;SnowFlake的结构如下(每部分用-分开):&lt;br&gt;0-0000000000 0000000000 0000000000 0000000000 0-00000-00000-000000000000&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>@Dict注解实现数据字典</title>
    <link href="https://lastsummer.top/blog/2020/03/11/Dict%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8/"/>
    <id>https://lastsummer.top/blog/2020/03/11/Dict注解实现数据字典/</id>
    <published>2020-03-11T11:34:47.000Z</published>
    <updated>2020-03-11T11:51:52.138Z</updated>
    
    <content type="html"><![CDATA[<p>@Dict注解实现数据字典。<a id="more"></a></p><h3 id="Dict注解类"><a href="#Dict注解类" class="headerlink" title="@Dict注解类"></a>@Dict注解类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 类描述:  字典注解</span><br><span class="line"> * 作    者： wr</span><br><span class="line"> * 日    期： 2019-3-9</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Dict &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 方法描述:  数据code</span><br><span class="line">     */</span><br><span class="line">    String dicCode();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 方法描述:  数据Text</span><br><span class="line">     */</span><br><span class="line">    String dicText() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 方法描述: 数据字典表</span><br><span class="line">     *</span><br><span class="line">     * @return 返回类型： String</span><br><span class="line">     */</span><br><span class="line">    String dictTable() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DictInteceptor-实现-Mybatis-Interceptor"><a href="#DictInteceptor-实现-Mybatis-Interceptor" class="headerlink" title="DictInteceptor 实现 Mybatis Interceptor"></a>DictInteceptor 实现 Mybatis Interceptor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 字典替换拦截器，当注解方法被执行后拦截并修改查询后的结果</span><br><span class="line"> *</span><br><span class="line"> * @ClassName: DictInteceptor</span><br><span class="line"> * 作    者： wr</span><br><span class="line"> * 日    期： 2019-3-9</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">@Intercepts(&#123;</span><br><span class="line">        @Signature(type = ResultSetHandler.class, method = &quot;handleResultSets&quot;, args = &#123;Statement.class&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">public class DictInteceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">    private BaseDictMapper baseDictMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(value = &#123;&quot;all&quot;&#125;)</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        //因为 handleResultSets  方法执行结束后可以收到一个list类型的数据结果集，</span><br><span class="line">        //所以虽然该方法的目的是用于结束本次拦截，执行预定方法（handleResultSets）方便下次拦截</span><br><span class="line">        long time1=System.currentTimeMillis();</span><br><span class="line">        List&lt;Object&gt; results = (List&lt;Object&gt;) invocation.proceed();</span><br><span class="line">        long time2=System.currentTimeMillis();</span><br><span class="line">        log.info(&quot;获取JSON数据 耗时：&quot;+(time2-time1)+&quot;ms&quot;);</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (null != results &amp;&amp; results.size() &gt; 0) &#123;</span><br><span class="line">                Class&lt;?&gt; cls = results.get(0).getClass();</span><br><span class="line">                Field[] fields = cls.getDeclaredFields();</span><br><span class="line">                for (Object result : results) &#123;</span><br><span class="line">                    for (Field field : oConvertUtils.getAllFields(result)) &#123;</span><br><span class="line">                        if (field.getAnnotation(Dict.class) != null) &#123;</span><br><span class="line">                            Dict dict = field.getAnnotation(Dict.class);</span><br><span class="line">                            if (dict != null) &#123;//如果存在这个注解 我们在执行后续方法</span><br><span class="line">                                String code = dict.dicCode();</span><br><span class="line">//                                String text = dict.dicText();</span><br><span class="line">//                                String table = dict.dictTable();</span><br><span class="line">                                Field idField = null;</span><br><span class="line">                                Field idFieldStr = null;</span><br><span class="line">                                //获取实体类对应字段</span><br><span class="line">                                idField = cls.getDeclaredField(field.getName());</span><br><span class="line">                                //获取实体类对应字段</span><br><span class="line">                                idFieldStr = cls.getDeclaredField(field.getName()+&quot;Str&quot;);</span><br><span class="line">                                //允许我们在用反射时访问私有变量</span><br><span class="line">                                idField.setAccessible(true);</span><br><span class="line">                                //从返回值中获得字段对应的值</span><br><span class="line">                                Object key = idField.get(result);</span><br><span class="line">                                idField.setAccessible(false);</span><br><span class="line">                                String textValue = translateDictValue(code, key);</span><br><span class="line">                                idFieldStr.setAccessible(true);</span><br><span class="line">                                 //用字典id查询出字典名称 并替换结果集中的值</span><br><span class="line">                                idFieldStr.set(result, textValue); </span><br><span class="line">                                idFieldStr.setAccessible(false);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            long end=System.currentTimeMillis();</span><br><span class="line">            log.info(&quot;解析注入JSON数据  耗时&quot;+(end-start)+&quot;ms&quot;);</span><br><span class="line">            return results;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  翻译字典文本</span><br><span class="line">     * @param code</span><br><span class="line">     * @param text</span><br><span class="line">     * @param table</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private String translateDictValue(String code, Object key) &#123;</span><br><span class="line">        if(ObjectUtils.isEmpty(key)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer textValue=new StringBuffer();</span><br><span class="line">        String[] keys = String.valueOf(key).split(&quot;,&quot;);</span><br><span class="line">        for (String k : keys) &#123;</span><br><span class="line">            String tmpValue = null;</span><br><span class="line">            if (k.trim().length() == 0) &#123;</span><br><span class="line">                continue; //跳过循环</span><br><span class="line">            &#125;</span><br><span class="line">            //Interceptor中不允许注入Bean，工具类 ApplicationContextUtils 注入</span><br><span class="line">            if(baseDictMapper == null)</span><br><span class="line">                baseDictMapper = (BaseDictMapper) </span><br><span class="line">                ApplicationContextUtils.getBean(&quot;baseDictMapper&quot;);</span><br><span class="line">            QueryWrapper&lt;BaseDict&gt; queryWrapper = new QueryWrapper();</span><br><span class="line">            queryWrapper.select(&quot;label&quot;);</span><br><span class="line">            queryWrapper.lambda()</span><br><span class="line">                    .eq(BaseDict::getType, code)</span><br><span class="line">                    .eq(BaseDict::getValue, k.trim());</span><br><span class="line">            //已集成缓存</span><br><span class="line">            tmpValue = baseDictMapper.selectOne(queryWrapper).getLabel();</span><br><span class="line">            if (tmpValue != null) &#123;</span><br><span class="line">                if (!&quot;&quot;.equals(textValue.toString())) &#123;</span><br><span class="line">                    textValue.append(&quot;,&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                textValue.append(tmpValue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return textValue.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        return Plugin.wrap(target, this);//返回代理</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ApplicationContextUtils-工具类"><a href="#ApplicationContextUtils-工具类" class="headerlink" title="ApplicationContextUtils 工具类"></a>ApplicationContextUtils 工具类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ApplicationContextUtils implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        ApplicationContextUtils.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getBean(String name) &#123;</span><br><span class="line">        return applicationContext.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return applicationContext.getBean(name, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return applicationContext.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考博客：<a href="http://www.hellojava.com/a/72278.html" target="_blank" rel="noopener">mybaits拦截器+自定义注解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@Dict注解实现数据字典。&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务解决方案</title>
    <link href="https://lastsummer.top/blog/2020/03/04/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://lastsummer.top/blog/2020/03/04/分布式事务解决方案/</id>
    <published>2020-03-04T08:26:00.000Z</published>
    <updated>2020-03-04T11:14:05.982Z</updated>
    
    <content type="html"><![CDATA[<p>分布式事务的五种解决方案。<a id="more"></a></p><h3 id="事务的四种特性（ACID）"><a href="#事务的四种特性（ACID）" class="headerlink" title="事务的四种特性（ACID）"></a>事务的四种特性（ACID）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原子性(A)整个事务中要么全部成功要么全部失败</span><br><span class="line">一致性(C)A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变</span><br><span class="line">   事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</span><br><span class="line">隔离性(I)事务之间不会相互影响</span><br><span class="line">持久性(D)事务完成后保存到数据库（持久化）</span><br></pre></td></tr></table></figure><h3 id="CAP原则"><a href="#CAP原则" class="headerlink" title="CAP原则"></a>CAP原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C Consistency:强一致性 强调的是数据正确，一定正确的数据</span><br><span class="line">A Availability:可用性 强调的是不出错，不保证最新数据</span><br><span class="line">P Partition tolerance:分区容忍性 强调不挂掉，节点同步数据丢失或者延迟也不会挂掉</span><br></pre></td></tr></table></figure><h3 id="分布式事务的产生的原因"><a href="#分布式事务的产生的原因" class="headerlink" title="分布式事务的产生的原因"></a>分布式事务的产生的原因</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">微服务-数据库分库分表</span><br><span class="line">应用服务化（SOA），多个业务中心对应各自的数据库</span><br></pre></td></tr></table></figure><h3 id="分布式事务的五种解决方案"><a href="#分布式事务的五种解决方案" class="headerlink" title="分布式事务的五种解决方案"></a>分布式事务的五种解决方案</h3><h4 id="XA-方案"><a href="#XA-方案" class="headerlink" title="XA 方案"></a>XA 方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全票通过方案，要求事务全部准备好，才进行事务处理</span><br><span class="line">优点：将事务问题抛给数据库本身，一致性高</span><br><span class="line">缺点：耗费性能，一般用的不多</span><br></pre></td></tr></table></figure><h4 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部通过方案，要求部分事务准备好即可，相对XA方案灵活很多</span><br><span class="line">优点：将事务问题交给系统本身，一致性很高</span><br><span class="line">缺点：大量的代码控制，控制事务的逻辑复杂冗余，性能较差，一般用的不多</span><br></pre></td></tr></table></figure><h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">基于数据库，由各个系统分别建立自己的消息表，记录数据的发起及接收，并给数据做状态标记，通过</span><br><span class="line">MQ，观察消息的状态来决定事务是否需要回滚</span><br><span class="line">优点：代码量少，数据可以保持最终一致性</span><br><span class="line">缺点：表需要维护，且对高并发支持并不好</span><br></pre></td></tr></table></figure><h4 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用的方案，借助MQ，由系统发起一条预发送信息，当系统本身的事务执行完毕后再将MQ中的消息变成</span><br><span class="line">确认消息，同样其它系统接收到MQ的消息后开始处理本地事务，根据处理情况决定是否回滚</span><br><span class="line">优点：事务控制灵活</span><br><span class="line">缺点：不稳定因素较多</span><br></pre></td></tr></table></figure><h4 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方案尚不成熟，有系统处理完本地事务后发起MQ，而接收方是本地的一套专门处理事务的服务，此服务</span><br><span class="line">调用待接收系统的接口。</span><br><span class="line">优点：事务节点较少</span><br><span class="line">缺点：事务处理的维护成本较高，同时需要多个系统的接口才行</span><br></pre></td></tr></table></figure><p>参考博客：<a href="https://blog.csdn.net/zzhuan_1/article/details/86615421" target="_blank" rel="noopener">分布式事物常见的5种解决方案-详细篇章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式事务的五种解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式事务" scheme="https://lastsummer.top/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker自定义redis镜像</title>
    <link href="https://lastsummer.top/blog/2020/02/29/Docker%E8%87%AA%E5%AE%9A%E4%B9%89redis%E9%95%9C%E5%83%8F/"/>
    <id>https://lastsummer.top/blog/2020/02/29/Docker自定义redis镜像/</id>
    <published>2020-02-29T15:35:26.000Z</published>
    <updated>2020-02-29T15:52:38.231Z</updated>
    
    <content type="html"><![CDATA[<p>Docker自定义redis镜像。<a id="more"></a></p><h3 id="DockerFile配置"><a href="#DockerFile配置" class="headerlink" title="DockerFile配置"></a>DockerFile配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER wangrui&lt;15034005712@163.com&gt;</span><br><span class="line"></span><br><span class="line">RUN yum -y install gcc make pcre-devel zlib-devel tar zlib</span><br><span class="line"></span><br><span class="line">ADD redis-4.0.8.tar.gz /usr/src/</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line"># redis配置</span><br><span class="line">RUN cd /usr/src/redis-4.0.8 &amp;&amp; make &amp;&amp; make install PREFIX=/usr/local/redis</span><br><span class="line">RUN cd /usr/local/redis</span><br><span class="line">COPY redis.conf /usr/local/redis/redis.conf</span><br><span class="line">RUN rm -rf /usr/src/redis-4.0.8</span><br><span class="line"></span><br><span class="line"># 容器卷（持久化数据到宿主机）</span><br><span class="line">VOLUME [&quot;/docker/redis/&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line"></span><br><span class="line">CMD [&quot;/usr/local/redis/bin/redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;]</span><br></pre></td></tr></table></figure><h3 id="redis-conf配置"><a href="#redis-conf配置" class="headerlink" title="redis.conf配置"></a>redis.conf配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）注释掉bind 127.0.0.1（外网访问）</span><br><span class="line">（2）添加daemonize no（解决启动报错）</span><br><span class="line">（3）修改protected-mode yes-&gt;no（外网访问）</span><br><span class="line">（4）添加requirepass yourpassword（自定义auth密码）</span><br><span class="line">（5）dir /docker/redis/（容器卷持久化redis数据到宿主机）可选</span><br><span class="line">（6）logfile &quot;/docker/redis/redis.log&quot;（容器卷持久化日志到宿主机）可选</span><br></pre></td></tr></table></figure><h3 id="Docker指令"><a href="#Docker指令" class="headerlink" title="Docker指令"></a>Docker指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker build -f ./Dockerfile it redis .</span><br><span class="line">docker run -d -p 6379:6379 redis</span><br><span class="line"># 获取容器/镜像的元数据。</span><br><span class="line">docker inspect 容器ID</span><br><span class="line"># 删除镜像</span><br><span class="line">docker rmi -f redis</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker自定义redis镜像。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://lastsummer.top/blog/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://lastsummer.top/blog/tags/Docker/"/>
    
      <category term="Redis" scheme="https://lastsummer.top/blog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="https://lastsummer.top/blog/2020/02/19/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://lastsummer.top/blog/2020/02/19/Docker常用命令/</id>
    <published>2020-02-19T12:22:04.000Z</published>
    <updated>2020-02-19T12:53:27.749Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 常用命令。<a id="more"></a></p><h3 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 搜索Docker Hub中的镜像</span><br><span class="line">docker search java</span><br><span class="line"># 从Docker Hub下载最新的java</span><br><span class="line">docker pull java</span><br><span class="line"># Docker Registry地址/仓库/镜像名称:标签</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/wangrui15034005712/nginx</span><br><span class="line"># 列出本地所有镜像，默认过滤中间映像层</span><br><span class="line">docker images -a</span><br><span class="line"># 删除指定镜像</span><br><span class="line">docker rmi -f [镜像名称]</span><br><span class="line"># 删除全部镜像</span><br><span class="line">docker rmi -f $(docker images)</span><br><span class="line"># 构建镜像 -t 设置签名</span><br><span class="line">docker build -t nginx:wr .</span><br><span class="line"># 启动容器 -d 后台启动，并打印容器ID -p 指定映射端口</span><br><span class="line">docker run -d -p 8080:8080 nginx:wr</span><br><span class="line"># 累出运行中的容器 -a 列出所有容器（包括未运行容器）</span><br><span class="line">docker ps -a</span><br><span class="line"># 停止容器</span><br><span class="line">docker stop 容器ID</span><br><span class="line"># 强制停止容器</span><br><span class="line">docker kill 容器ID</span><br><span class="line"># 启动已停止的容器</span><br><span class="line">docker statr 容器ID</span><br><span class="line"># 重新启动容器</span><br><span class="line">docker restatr 容器ID</span><br><span class="line"># 进入容器</span><br><span class="line">docker attach 容器ID</span><br><span class="line"># 删除容器指定容器</span><br><span class="line">docker rm [容器ID]</span><br><span class="line"># 删除全部容器 -q 只展示容器ID</span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br><span class="line"># 将指定容器导出tar包 --output将内容写入文件而非标准输出</span><br><span class="line">docker export 容器名称 &gt; app.tar</span><br><span class="line">docker export --output &gt; app.tar</span><br><span class="line"># 引入容器并创建nginx镜像</span><br><span class="line">docker import app.tar nginx</span><br><span class="line"># 保存镜像</span><br><span class="line">docker save 容器名称 &gt; app.tar</span><br><span class="line">docker save --output app.tar 容器名称</span><br><span class="line"># 加载镜像 --input 从文件加载而非标准输入</span><br><span class="line">docker load &lt; app.tar</span><br><span class="line">docker load --input app.tar</span><br><span class="line"># docker Hub注册后才可登录</span><br><span class="line">docker login</span><br><span class="line"># 推送镜像</span><br><span class="line">docker push wangrui/nginx:wr</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 常用命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://lastsummer.top/blog/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://lastsummer.top/blog/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Mysql基础函数及行转列</title>
    <link href="https://lastsummer.top/blog/2020/02/18/Mysql%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0%E5%8F%8A%E8%A1%8C%E8%BD%AC%E5%88%97/"/>
    <id>https://lastsummer.top/blog/2020/02/18/Mysql基础函数及行转列/</id>
    <published>2020-02-18T12:17:18.000Z</published>
    <updated>2020-02-18T13:07:46.405Z</updated>
    
    <content type="html"><![CDATA[<p>MYSQL借用<b>mysql.help_topic</b>生成连续的日期。<br><b>mysql.help_topic</b>是一个从0开始到506的一个序列组（列转行、生成连续日期等）。<br><a id="more"></a></p><h3 id="生成连续的日期"><a href="#生成连续的日期" class="headerlink" title="生成连续的日期"></a>生成连续的日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  date_format(date_add(SYSDATE(),INTERVAL-t.help_topic_id DAY),&apos;%Y-%m-%d&apos;) </span><br><span class="line">FROM</span><br><span class="line">  mysql.help_topic t </span><br><span class="line">WHERE</span><br><span class="line">  t.help_topic_id &lt; 10</span><br></pre></td></tr></table></figure><p><img src="/blog/2020/02/18/Mysql基础函数及行转列/mysql.png" alt=""></p><h3 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">create table group_by(</span><br><span class="line">name VARCHAR(50),</span><br><span class="line">class VARCHAR(50),</span><br><span class="line">item VARCHAR(50),</span><br><span class="line">price int(10)</span><br><span class="line">)</span><br><span class="line">insert into GROUP_BY VALUES (&apos;张三&apos;,&apos;一班&apos;,&apos;3&apos;,20);</span><br><span class="line">insert into GROUP_BY VALUES (&apos;张三&apos;,&apos;二班&apos;,&apos;5&apos;,70);</span><br><span class="line">insert into GROUP_BY VALUES (&apos;张三&apos;,&apos;三班&apos;,&apos;6&apos;,54);</span><br><span class="line">insert into GROUP_BY VALUES (&apos;李四&apos;,&apos;一班&apos;,&apos;9&apos;,80);</span><br><span class="line">insert into GROUP_BY VALUES (&apos;李四&apos;,&apos;二班&apos;,&apos;2&apos;,50);</span><br><span class="line"># mysql分组小计和合计</span><br><span class="line">SELECT</span><br><span class="line">case when c.name is null then &apos;合计&apos; </span><br><span class="line">else c.name end as name,</span><br><span class="line">case when c.name is null then &apos;&apos;</span><br><span class="line">  when c.class is null then &apos;小计&apos;</span><br><span class="line">else c.class end as class,</span><br><span class="line">c.item as item,</span><br><span class="line">sum(c.price) as price</span><br><span class="line">FROM</span><br><span class="line">GROUP_BY c</span><br><span class="line">GROUP BY</span><br><span class="line">c.NAME,</span><br><span class="line">c.class WITH ROLLUP</span><br></pre></td></tr></table></figure><p><img src="/blog/2020/02/18/Mysql基础函数及行转列/mysql1.png" alt="基础数据"><br><img src="/blog/2020/02/18/Mysql基础函数及行转列/mysql2.jpg" alt="行专列实现分组小计合计"></p><h3 id="IFNULL出现乱码"><a href="#IFNULL出现乱码" class="headerlink" title="IFNULL出现乱码"></a>IFNULL出现乱码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFNULL( cast(t2.maleTotal as CHAR), &apos;&apos; )</span><br></pre></td></tr></table></figure><h3 id="sum-case-when返回0-0"><a href="#sum-case-when返回0-0" class="headerlink" title="sum case when返回0.0"></a>sum case when返回0.0</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUM( CASE `register_sex` WHEN &apos;1&apos; THEN &quot;1&quot; ELSE &apos;0&apos; END ) #后边的1和0不加符号</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MYSQL借用&lt;b&gt;mysql.help_topic&lt;/b&gt;生成连续的日期。&lt;br&gt;&lt;b&gt;mysql.help_topic&lt;/b&gt;是一个从0开始到506的一个序列组（列转行、生成连续日期等）。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://lastsummer.top/blog/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://lastsummer.top/blog/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>使用Dockerfile构建及推送镜像</title>
    <link href="https://lastsummer.top/blog/2020/02/16/%E4%BD%BF%E7%94%A8Dockerfile%E6%9E%84%E5%BB%BA%E5%8F%8A%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F/"/>
    <id>https://lastsummer.top/blog/2020/02/16/使用Dockerfile构建及推送镜像/</id>
    <published>2020-02-16T04:25:13.000Z</published>
    <updated>2020-02-16T06:09:11.219Z</updated>
    
    <content type="html"><![CDATA[<p>Dockerfile是一个文本文件，包含若干条指令，描述了构建镜像的细节。<br>1、<b>Dockerfile</b>修改<b>Nginx</b>镜像的首页。<br>2、<b>Docker部署jar包运行</b>。<a id="more"></a></p><h3 id="Dockerfile修改Nginx镜像的首页"><a href="#Dockerfile修改Nginx镜像的首页" class="headerlink" title="Dockerfile修改Nginx镜像的首页"></a>Dockerfile修改Nginx镜像的首页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@root ~]# mkdir docker</span><br><span class="line">[root@root ~]# cd docker</span><br><span class="line">[root@root ~]# vi Dockerfile# D开头必须大写</span><br><span class="line">FROM nginx</span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello Docker&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br><span class="line">[root@root ~]# docker build -t nginx:wr .# mynginx表示标签 . 表示当前目录</span><br><span class="line">#上行代码如有报错 手打一次即可（编码、空格等问题）</span><br><span class="line">[root@root ~]# docker run -d -p 8888:80 nginx:wr #启动创建的镜像</span><br></pre></td></tr></table></figure><p><img src="/blog/2020/02/16/使用Dockerfile构建及推送镜像/docker.png" alt=""></p><h3 id="Docker部署Jar包运行"><a href="#Docker部署Jar包运行" class="headerlink" title="Docker部署Jar包运行"></a>Docker部署Jar包运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@root ~]# mkdir eureka</span><br><span class="line">[root@root ~]# cd eureka</span><br><span class="line">[root@root ~]# vi Dockerfile# D开头必须大写</span><br><span class="line"></span><br><span class="line"># 基于java镜像</span><br><span class="line">FROM java:8</span><br><span class="line"></span><br><span class="line"># 作者</span><br><span class="line">MAINTAINER wr</span><br><span class="line"></span><br><span class="line"># 复制文件到容器</span><br><span class="line">ADD eureka.jar eureka.jar</span><br><span class="line"></span><br><span class="line"># 声明需要暴露的端口</span><br><span class="line">EXPOSE 8761</span><br><span class="line"></span><br><span class="line"># 配置容器启动后执行的命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;eureka.jar&quot;]</span><br><span class="line"></span><br><span class="line">[root@root ~]# docker build -t wr/eureka:wr . </span><br><span class="line"># -t 指定镜像的仓库名称/镜像名称：标签名称</span><br><span class="line"></span><br><span class="line">[root@root ~]# docker run -d -p 8761:8761 wr/eureka:wr </span><br><span class="line"># -d 后台启动容器，打印容器ID -p 映射端口</span><br></pre></td></tr></table></figure><p><img src="/blog/2020/02/16/使用Dockerfile构建及推送镜像/docker1.png" alt=""></p><h3 id="推送-Docker镜像到Docker-Hub官网"><a href="#推送-Docker镜像到Docker-Hub官网" class="headerlink" title="推送 Docker镜像到Docker Hub官网"></a>推送 Docker镜像到Docker Hub官网</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在[Docker官网](https://lastsummer.top)注册、登录并创建存储库 wangrui</span><br><span class="line">登录docker账号</span><br><span class="line">[root@root ~]# docker login</span><br><span class="line">Username: wangrui</span><br><span class="line">Password:</span><br><span class="line">Login Succeeded</span><br><span class="line">[root@root ~]# docker images</span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                      wr                  9f21117959fe        About an hour ago   127 MB</span><br><span class="line"># tag 打标签 wangrui 为你的 docker hub名字</span><br><span class="line">[root@root ~]# docker tag 9f21117959fe wangrui/nginx:wr</span><br><span class="line">[root@root ~]# docker push wangrui/nginx:wr</span><br></pre></td></tr></table></figure><h3 id="推送-Docker-镜像到-阿里云-官网"><a href="#推送-Docker-镜像到-阿里云-官网" class="headerlink" title="推送 Docker 镜像到 阿里云 官网"></a>推送 Docker 镜像到 阿里云 官网</h3><p>1、<a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">注册阿里云账户</a><br>2、登陆账户<br>3、<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">配置Docker加速器</a><br>4、<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/namespaces" target="_blank" rel="noopener">创建镜像仓库的命名空间</a><br>5、<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/repositories" target="_blank" rel="noopener">创建镜像仓库</a><br>6、操作指南(登录及推送镜像)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker login --username=wangrui registry-internal.cn-hangzhou.aliyuncs.com</span><br><span class="line">$ sudo docker tag [imagesId] registry-internal.cn-hangzhou.aliyuncs.com/wangrui/nginx:wr</span><br><span class="line">$ sudo docker push registry-internal.cn-hangzhou.aliyuncs.com/wangrui/nginx:wr</span><br></pre></td></tr></table></figure></p><p>参考博客：<a href="https://blog.csdn.net/qq_16605855/article/details/79961933" target="_blank" rel="noopener">Docker镜像上传到阿里云的步骤详解</a><br>参考博客：<a href="https://blog.csdn.net/weixin_42054155/article/details/90815393" target="_blank" rel="noopener">Docker部署jar包运行</a><br>参考博客：<a href="https://yangfannie.com/1272.html" target="_blank" rel="noopener">推送你的镜像到Docker Hub</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dockerfile是一个文本文件，包含若干条指令，描述了构建镜像的细节。&lt;br&gt;1、&lt;b&gt;Dockerfile&lt;/b&gt;修改&lt;b&gt;Nginx&lt;/b&gt;镜像的首页。&lt;br&gt;2、&lt;b&gt;Docker部署jar包运行&lt;/b&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://lastsummer.top/blog/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://lastsummer.top/blog/tags/Docker/"/>
    
      <category term="Nginx" scheme="https://lastsummer.top/blog/tags/Nginx/"/>
    
      <category term="Linux" scheme="https://lastsummer.top/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="https://lastsummer.top/blog/2020/02/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>https://lastsummer.top/blog/2020/02/05/分布式事务/</id>
    <published>2020-02-05T13:10:38.000Z</published>
    <updated>2020-02-05T13:47:59.103Z</updated>
    
    <content type="html"><![CDATA[<p>分布式有很多种实现方式，本文讲解可靠消息模式，通过消息队列实现。<a id="more"></a></p><h3 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h3><p>一个大的操作由两个或者更多的小的系统操作共同完成。而这些小的操作又分布在不同的网络主机上。这些操作，要么全部成功执行，要么全部不执行。<br>本质上就是说：分布式事务就是为了保证不同系统、不同数据库的数据一致性。</p><h3 id="消息队列实现分布式事务"><a href="#消息队列实现分布式事务" class="headerlink" title="消息队列实现分布式事务"></a>消息队列实现分布式事务</h3><p>1、把消息写入数据库的消息表（消息表：内容、状态等）<br>2、后台运行定时任务、每次执行从消息表中获取未发送的消息发送到队列，确认返回后修改已发送状态<br>3、重复消息幂等性（创建判重表，判断是否已处理过）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、上游系统保证消息不丢 通过本地消息和后台定时任务程序实现<br>2、下游系统保证消息不重复处理，保证幂等性</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>分布式失误的提交或回滚只取决于事务发起方，也就是无需回滚</p><p><img src="/blog/2020/02/05/分布式事务/分布式事务.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式有很多种实现方式，本文讲解可靠消息模式，通过消息队列实现。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式事务" scheme="https://lastsummer.top/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="队列" scheme="https://lastsummer.top/blog/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="https://lastsummer.top/blog/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客部署Nginx</title>
    <link href="https://lastsummer.top/blog/2020/02/04/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2Nginx/"/>
    <id>https://lastsummer.top/blog/2020/02/04/Hexo博客部署Nginx/</id>
    <published>2020-02-04T12:00:05.000Z</published>
    <updated>2020-02-04T12:37:46.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hexo部署方法"><a href="#Hexo部署方法" class="headerlink" title="Hexo部署方法"></a>Hexo部署方法</h3><p>部署hexo静态博客到生产环境通常有两种方法<br>1、nohup命令执行hexo s由于hexo s，是框架提供的调试方法，不是部署方式，因此在生产环境会存在性能问题不建议使用<br>2、nginx部署静态资源将本地调试好的hexo打包生成的public目录部署到nginx上。nginx性能好访问速度快<a id="more"></a></p><h3 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h3><h4 id="部署在根目录无需处理"><a href="#部署在根目录无需处理" class="headerlink" title="部署在根目录无需处理"></a>部署在根目录无需处理</h4><p>打包：通常在调试环境无需打包，修改后使用hexo s，即可生效，可以直接在本地查看效果。但是，以静态资源的方式部署需要打包生成静态资源，命令为：hexo generate到public文件夹中。</p><h4 id="处理二级目录"><a href="#处理二级目录" class="headerlink" title="处理二级目录"></a>处理二级目录</h4><p>当生产环境中，静态博客部署在二级目录下（如：“http://域名(ip)/blog”这种情况），需要修改hexo工程下的_config.yml配置文件，否则打包生成的css、js文件目录会缺失（默认在根目录），导致无法加载样式。<br>一般修改root和url,增加二级目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: http://lastsummer.top/blog</span><br><span class="line">root: /blog</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></p><h3 id="nginx配置-HTTPS（阿里云申请SSL证书配置即可）"><a href="#nginx配置-HTTPS（阿里云申请SSL证书配置即可）" class="headerlink" title="nginx配置+HTTPS（阿里云申请SSL证书配置即可）"></a>nginx配置+HTTPS（阿里云申请SSL证书配置即可）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1、部署在根目录无需处理，放到nginx webapp中即可</span><br><span class="line">2、部署到二级目录则在webapp中新建二级目录名称，把静态文件放入到二级目录下</span><br><span class="line"> server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.lastsummer.top;</span><br><span class="line">rewrite ^(.*)$ https://$host$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443; </span><br><span class="line">    server_name lastsummer.top;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate  lastsummer.top.pem;</span><br><span class="line">    ssl_certificate_key lastsummer.top.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">root /usr/local/nginx/;</span><br><span class="line">index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">location ^~ /blog &#123;</span><br><span class="line">root /usr/local/nginx;</span><br><span class="line">&#125;</span><br><span class="line">#...缓存等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐博客：<a href="https://www.jianshu.com/p/62acf17b1710" target="_blank" rel="noopener">nginx部署hexo的方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hexo部署方法&quot;&gt;&lt;a href=&quot;#Hexo部署方法&quot; class=&quot;headerlink&quot; title=&quot;Hexo部署方法&quot;&gt;&lt;/a&gt;Hexo部署方法&lt;/h3&gt;&lt;p&gt;部署hexo静态博客到生产环境通常有两种方法&lt;br&gt;1、nohup命令执行hexo s由于hexo s，是框架提供的调试方法，不是部署方式，因此在生产环境会存在性能问题不建议使用&lt;br&gt;2、nginx部署静态资源将本地调试好的hexo打包生成的public目录部署到nginx上。nginx性能好访问速度快&lt;/p&gt;
    
    </summary>
    
      <category term="HEXO" scheme="https://lastsummer.top/blog/categories/HEXO/"/>
    
    
      <category term="Git" scheme="https://lastsummer.top/blog/tags/Git/"/>
    
      <category term="Nginx" scheme="https://lastsummer.top/blog/tags/Nginx/"/>
    
      <category term="Linux" scheme="https://lastsummer.top/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装和使用</title>
    <link href="https://lastsummer.top/blog/2020/02/03/Docker%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://lastsummer.top/blog/2020/02/03/Docker安装和使用/</id>
    <published>2020-02-03T08:34:36.000Z</published>
    <updated>2020-02-04T12:38:01.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Docker时dotCloud公司开源的一个基于LXC技术之上搭建的Container容器引擎，源代码托管在Github上，基于Go语言并遵从Apache2.0协议开源。<br>Docker属于Linux容器的一种封装，提供简单易用的容器使用接口。<br>Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker，就不用担心环境问题。<br>总体来说，Docker的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。<br><b>同时 Docker 划分为 CE 和 EE。CE 即社区版（免费，支持周期三个月），EE 即企业版，强调安全，付费使用。<b><a id="more"></a></b></b></p><h3 id="CentOS安装Docker-CE"><a href="#CentOS安装Docker-CE" class="headerlink" title="CentOS安装Docker CE"></a>CentOS安装Docker CE</h3><h4 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h4><p>目前，CentOS 仅发行版本中的内核支持 Docker。<br>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</p><h4 id="使用-yum-安装（CentOS-7）"><a href="#使用-yum-安装（CentOS-7）" class="headerlink" title="使用 yum 安装（CentOS 7）"></a>使用 yum 安装（CentOS 7）</h4><p>通过 uname -r 命令查看你当前的内核版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@1234qwer ~]# uname -r </span><br><span class="line">3.10.0-957.21.2.el7.x86_64</span><br></pre></td></tr></table></figure></p><h4 id="更新系统-可选"><a href="#更新系统-可选" class="headerlink" title="更新系统(可选)"></a>更新系统(可选)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h4 id="安装-Dockedr-CE"><a href="#安装-Dockedr-CE" class="headerlink" title="安装 Dockedr CE"></a>安装 Dockedr CE</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br><span class="line"># Docker 版本</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h4 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><h3 id="Docker-命令"><a href="#Docker-命令" class="headerlink" title="Docker 命令"></a>Docker 命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 从Docker Hub下载tomcat最新版镜像</span><br><span class="line">docker pull tomcat</span><br><span class="line"># 启动tomcat容器</span><br><span class="line">docker run -d -p 8080:16000 tomcat</span><br><span class="line"># 列出所有在运行的容器信息。</span><br><span class="line">docker ps </span><br><span class="line"># Docker 运行容器ID控制台：</span><br><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line"># 两种退出容器的方式</span><br><span class="line">docker kill 容器ID</span><br><span class="line">docker stop 容器ID</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Docker时dotCloud公司开源的一个基于LXC技术之上搭建的Container容器引擎，源代码托管在Github上，基于Go语言并遵从Apache2.0协议开源。&lt;br&gt;Docker属于Linux容器的一种封装，提供简单易用的容器使用接口。&lt;br&gt;Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker，就不用担心环境问题。&lt;br&gt;总体来说，Docker的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。&lt;br&gt;&lt;b&gt;同时 Docker 划分为 CE 和 EE。CE 即社区版（免费，支持周期三个月），EE 即企业版，强调安全，付费使用。&lt;b&gt;&lt;/b&gt;&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://lastsummer.top/blog/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://lastsummer.top/blog/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>JWT生成TOKEN</title>
    <link href="https://lastsummer.top/blog/2020/01/25/JWT%E7%94%9F%E6%88%90TOKEN/"/>
    <id>https://lastsummer.top/blog/2020/01/25/JWT生成TOKEN/</id>
    <published>2020-01-25T03:26:15.000Z</published>
    <updated>2020-02-03T09:04:37.336Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Jwt 是一种生成token,或者解析token 返回对象的工具，现在流行的都是前后端分离项目，用之前的shiro,或者sercurity 去做权限是会遇到无法做前端的权限，所以就采用token 这种方式，服务器返回token  给前端，前端通过token 访问资源，前端通过cookie保存。<br><a id="more"></a></p><h3 id="什么是jwt"><a href="#什么是jwt" class="headerlink" title="什么是jwt"></a>什么是jwt</h3><p>WT本质上是一个字符串，一个完整的JWT由三部分组成，头部(header), 荷载(Payload), 和签名(Signature)，中间用.隔开，如下是一个典型的JWT：eyJhbGciOiJIUzUxMiJ9.iIxMjM0NSIsInN1YiI6InhsIn0.5MSq92FV7vneEo9IrrZw9XH6g<br><b>注意：保存的信息越多，生成的token长度越长<b></b></b></p><h3 id="JWT-头部（Header）"><a href="#JWT-头部（Header）" class="headerlink" title="JWT 头部（Header）"></a>JWT 头部（Header）</h3><p>用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。<br>{“typ”:”JWT”,”alg”:”HS256”}</p><h3 id="载荷（playload）"><a href="#载荷（playload）" class="headerlink" title="载荷（playload）"></a>载荷（playload）</h3><p>载荷就是存放有效信息的地方（自定义变量+标准变量）。</p><h3 id="签证（signature）"><a href="#签证（signature）" class="headerlink" title="签证（signature）"></a>签证（signature）</h3><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：<br>这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。<br>eyJhbGciOiJIUzUxMiJ9.iIxMjM0NSIsInN1YiI6InhsIn0.5MSq92FV7vneEo9IrrZw9XH6g</p><h3 id="引入依赖包"><a href="#引入依赖包" class="headerlink" title="引入依赖包"></a>引入依赖包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.6.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">``` </span><br><span class="line">### JWT工具类</span><br></pre></td></tr></table></figure><p>package com.zes.utils;</p><p>import com.zexx.springcloudcommon.exception.WebException;<br>import com.zexx.springcloudcommon.utils.StringUtil;<br>import io.jsonwebtoken.Claims;<br>import io.jsonwebtoken.Jwts;<br>import io.jsonwebtoken.SignatureAlgorithm;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.beans.factory.annotation.Value;<br>import org.springframework.data.redis.core.RedisTemplate;<br>import org.springframework.stereotype.Component;</p><p>import java.io.Serializable;<br>import java.util.Date;<br>import java.util.HashMap;<br>import java.util.Map;<br>import java.util.concurrent.TimeUnit;</p><p>/**</p><ul><li>Description: JWT生成token相关的工具类<br>*</li><li>@author wangrui</li><li><p>@date 2019/12/18<br>*/<br>@Component<br>public class JwtTokenUtil implements Serializable {</p><p> private static final long serialVersionUID = -4324967L;</p><p> //用户名称<br> private static final String CLAIM_KEY_USERNAME = “CLAIM_KEY_USERNAME”;<br> //创建时间<br> private static final String CLAIM_KEY_CREATE_TIME = “CLAIM_KEY_CREATE_TIME”;<br> //结束时间<br> private static final String CLAIM_KEY_END_TIME = “CLAIM_KEY_END_TIME”;</p><p> //注入redis<br> @Autowired<br> private RedisTemplate redisTemplate;</p><p> // JWT 密钥（服务器密钥加密解密 application.yml配置）<br> @Value(“${jwt.secret}”)<br> private String secret;</p><p> // redis存储时间 分钟 一般24小时<br> @Value(“${jwt.redisexpiration}”)<br> private Long redisExpiration;</p><p> //签发人<br> @Value(“${jwt.issuer}”)<br> private String issuer;</p><p> /**</p><ul><li>Description: 解析token，从token中获取信息<br>*</li><li><p>@param token<br>*/<br>private Claims getClaimsFromToken(String token) {<br> Claims claims;<br> try {</p><pre><code>claims = Jwts.parser()        .setSigningKey(secret)        .parseClaimsJws(token)        .getBody();</code></pre><p> } catch (Exception e) {</p><pre><code>e.printStackTrace();claims = null;</code></pre><p> }<br> return claims;<br>}</p><p>/**</p></li><li>Description:获取用户名<br>*</li><li><p>@param token<br>*/<br>public String getUserNameFromToken(String token) {<br> String userName;<br> try {</p><pre><code>final Claims claims = getClaimsFromToken(token);userName = claims.get(CLAIM_KEY_USERNAME) == null ? &quot;&quot; : claims.get(CLAIM_KEY_USERNAME).toString();</code></pre><p> } catch (Exception e) {</p><pre><code>userName = null;</code></pre><p> }<br> return userName;<br>}</p><p>/**</p></li><li>Description:获取token创建时间<br>*</li><li><p>@param token<br>*/<br>public Date getCreatedDateFromToken(String token) {<br> Date created;<br> try {</p><pre><code>final Claims claims = getClaimsFromToken(token);created = new Date((Long) claims.get(CLAIM_KEY_CREATE_TIME));</code></pre><p> } catch (Exception e) {</p><pre><code>created = null;</code></pre><p> }<br> return created;<br>}</p><p>/**</p></li><li>Description: 获取token过期时间<br>*</li><li><p>@param token<br>*/<br>public Date getExpirationDateFromToken(String token) {<br> Date expiration;<br> try {</p><pre><code>final Claims claims = getClaimsFromToken(token);expiration = claims.getExpiration();</code></pre><p> } catch (Exception e) {</p><pre><code>expiration = null;</code></pre><p> }<br> return expiration;<br>}</p><p>/**</p></li><li><p>Description:token生成过期时间<br><em>/<br>private Date generateExpirationDate() {<br> return new Date(System.currentTimeMillis() + redisExpiration </em> 60 * 1000);<br>}</p><p>/**</p></li><li>Description:token是否过期<br>*</li><li><p>@param token<br>*/<br>private Boolean isTokenExpired(String token) {<br> final Date expiration = getExpirationDateFromToken(token);<br> return expiration.before(new Date());<br>}</p><p>/**</p></li><li><p>Description: 创建token<br>*/<br>public String generateToken(String userName, String mac) {<br> Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();<br> claims.put(CLAIM_KEY_USERNAME, userName);<br> claims.put(CLAIM_KEY_CREATE_TIME, new Date());<br> claims.put(CLAIM_KEY_END_TIME, generateExpirationDate());<br> return generateToken(claims);<br>}</p><p>/**</p></li><li><p>Description:使用Rs256签名<br>*/<br>private String generateToken(Map&lt;String, Object&gt; claims) {<br> return Jwts.builder()</p><pre><code>.setClaims(claims)//自定义变量.setIssuer(issuer).setIssuedAt(new Date())//发行时间.setAudience((String) claims.get(CLAIM_KEY_USERNAME)).setExpiration(generateExpirationDate())//过期时间.signWith(SignatureAlgorithm.HS512, secret)//签名密钥.compact();</code></pre><p>}</p><p>/**</p></li><li>Description:验证token<br>*</li><li>@param token</li><li>@param userName</li><li>@param mac<br>*/<br>public boolean validateToken(String token, String userName, String mac) {<br> String tokenName = “”;<br> try {<pre><code>if (redisTemplate.hasKey(&quot;token_&quot; + userName)) {    tokenName = (String) redisTemplate.opsForValue().get(&quot;token_&quot; + userName);    if (tokenName.equals(token)) {        return true;    } else {        //自定义异常        throw new WebException(&quot;无效令牌&quot;);    }}</code></pre> } catch (WebException e) {<pre><code>throw new WebException(e.getMessage());</code></pre> }<br> return false;<br>}<br>}<br><code>`</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Jwt 是一种生成token,或者解析token 返回对象的工具，现在流行的都是前后端分离项目，用之前的shiro,或者sercurity 去做权限是会遇到无法做前端的权限，所以就采用token 这种方式，服务器返回token  给前端，前端通过token 访问资源，前端通过cookie保存。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://lastsummer.top/blog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>微服务下实现日志模块</title>
    <link href="https://lastsummer.top/blog/2019/12/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8B%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/"/>
    <id>https://lastsummer.top/blog/2019/12/09/微服务下实现日志模块/</id>
    <published>2019-12-09T08:39:48.000Z</published>
    <updated>2020-03-09T11:27:50.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微服务下实现日志模块"><a href="#微服务下实现日志模块" class="headerlink" title="微服务下实现日志模块"></a>微服务下实现日志模块</h3><p>与传统单体应用不同，微服务下由于，项目模块、业务拆分成多个独立系统，数据库一般也相互独立。<br>所以对于日志的统一管理和收集，也趋于复杂，借助于springboot自动配置和spring事件发布订阅（RabbitMq）、SpringAop以及组件化思想，构建一个通用日志模块<br><a id="more"></a></p><h4 id="自定义SysLog注解"><a href="#自定义SysLog注解" class="headerlink" title="自定义SysLog注解"></a>自定义SysLog注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义日志注解</span><br><span class="line"> * @author wangrui</span><br><span class="line"> * @date 2019-12-9</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SysLog &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 服务(子系统)名 默认取$&#123;spring.application.name&#125;</span><br><span class="line">     */</span><br><span class="line">    String serverName() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 日志描述信息</span><br><span class="line">     */</span><br><span class="line">    String description() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过Aop-pointCut拦截-SysLog的请求"><a href="#通过Aop-pointCut拦截-SysLog的请求" class="headerlink" title="通过Aop pointCut拦截@SysLog的请求"></a>通过Aop pointCut拦截@SysLog的请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * aop拦截</span><br><span class="line"> * @author wangrui</span><br><span class="line"> * @date 2019-06-09 17:47</span><br><span class="line"> */</span><br><span class="line">@Aspect</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">    private ThreadPoolTaskExecutor taskExecutor;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">    private AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.application.name&#125;&quot;)</span><br><span class="line">    private String serverName;</span><br><span class="line"></span><br><span class="line">    @Around(value = &quot;@annotation(SysLog)&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point, ZgLog zgLog) throws Throwable &#123;</span><br><span class="line">        String strClassName = point.getTarget().getClass().getName();</span><br><span class="line">        String strMethodName = point.getSignature().getName();</span><br><span class="line">        SysLog logVo = SysLogUtils.getSysLog();</span><br><span class="line">        logVo.setServerName(StringUtils.isNotBlank(zgLog.serverName()) ? zgLog.serverName() : serverName);</span><br><span class="line">        logVo.setModule(zgLog.module());</span><br><span class="line">        logVo.setDescription(zgLog.description());</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        Object obj = point.proceed();</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        logVo.setTime(endTime - startTime);</span><br><span class="line">1、直接执行保存操作</span><br><span class="line">this.logService.addLog(log);</span><br><span class="line">2、优化:异步保存日志</span><br><span class="line">new SaveLogThread(log, logService).start();</span><br><span class="line">3、再优化:通过线程池来执行日志保存</span><br><span class="line">threadPoolTaskExecutor.execute(new SaveLogThread(log, logService));</span><br><span class="line">logThreadLocal.set(log);</span><br><span class="line">        1、实现spirng消息发布及订阅</span><br><span class="line">        2、springboot连接池异步多线程发送消息</span><br><span class="line">        taskExecutor.execute(new MyThread());</span><br><span class="line">        3、mq异步发送保存日志信息</span><br><span class="line">        amqpTemplate.convertAndSend(&quot;springcloud.exchange&quot;,&quot;log&quot;, JSONObject.toJSONString(logVo));</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;微服务下实现日志模块&quot;&gt;&lt;a href=&quot;#微服务下实现日志模块&quot; class=&quot;headerlink&quot; title=&quot;微服务下实现日志模块&quot;&gt;&lt;/a&gt;微服务下实现日志模块&lt;/h3&gt;&lt;p&gt;与传统单体应用不同，微服务下由于，项目模块、业务拆分成多个独立系统，数据库一般也相互独立。&lt;br&gt;所以对于日志的统一管理和收集，也趋于复杂，借助于springboot自动配置和spring事件发布订阅（RabbitMq）、SpringAop以及组件化思想，构建一个通用日志模块&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="https://lastsummer.top/blog/categories/SpringCloud/"/>
    
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/tags/JAVA/"/>
    
      <category term="SpringBoot" scheme="https://lastsummer.top/blog/tags/SpringBoot/"/>
    
      <category term="SpringCloud" scheme="https://lastsummer.top/blog/tags/SpringCloud/"/>
    
      <category term="RabbitMQ" scheme="https://lastsummer.top/blog/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud基础</title>
    <link href="https://lastsummer.top/blog/2019/11/26/SpringCloud%E5%9F%BA%E7%A1%80/"/>
    <id>https://lastsummer.top/blog/2019/11/26/SpringCloud基础/</id>
    <published>2019-11-26T11:55:15.000Z</published>
    <updated>2019-11-27T08:58:11.959Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SpringCloud基础"><a href="#SpringCloud基础" class="headerlink" title="SpringCloud基础"></a>SpringCloud基础</h3><a id="more"></a><h4 id="微服务的优缺点"><a href="#微服务的优缺点" class="headerlink" title="微服务的优缺点"></a>微服务的优缺点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">微服务是一种架构模式，叫微服务架构更合理，把一个系统的各个功能点都拆开为一个个的应用单独部署</span><br><span class="line">优点：</span><br><span class="line">1.每个服务直接足够内聚，代码容易理解</span><br><span class="line">2.开发效率高，一个服务只做一件事，适合小团队开发</span><br><span class="line">3.松耦合，有功能意义的服务</span><br><span class="line">4.可以用不同语言开发，面向接口编程</span><br><span class="line">5.易于第三方集成</span><br><span class="line">6.微服务只是业务逻辑的代码，不会和HTML,CSS或其他界面结合</span><br><span class="line">7.可以灵活搭配，连接公共库/连接独立库</span><br><span class="line">缺点：</span><br><span class="line">1.分布式系统的责任性</span><br><span class="line">2.多服务运维难度加大</span><br><span class="line">3.系统部署依赖，服务间通信成本，数据一致性，系统集成测试，性能监控</span><br></pre></td></tr></table></figure><h4 id="springCloud"><a href="#springCloud" class="headerlink" title="springCloud?"></a>springCloud?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring cloud流应用程序启动器是基于Spring Boot的Spring集成应用程序，提供与外部系统的集成</span><br><span class="line">Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序</span><br><span class="line">相比Dubbo等RPC框架,Spring Cloud提供的全套的分布式系统解决方案</span><br></pre></td></tr></table></figure><h4 id="springCloud和Dubbo区别"><a href="#springCloud和Dubbo区别" class="headerlink" title="springCloud和Dubbo区别?"></a>springCloud和Dubbo区别?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.服务调用方式 dubbo基于RPC springcloud基于Rest Api</span><br><span class="line">2.注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper</span><br><span class="line">3.服务网关,dubbo本身没有实现，只能通过其他第三方技术整合</span><br><span class="line">springcloud有Zuul路由网关，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素</span><br></pre></td></tr></table></figure><h4 id="RPC和REST区别？"><a href="#RPC和REST区别？" class="headerlink" title="RPC和REST区别？"></a>RPC和REST区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REST是一种架构风格，REST规范把所有内容都视为资源，网络上一切皆资源</span><br><span class="line">REST并没有创造新的技术，组件或服务，只是使用Web的现有特征和能力</span><br><span class="line">完全通过HTTP协议实现，使用 HTTP 协议处理数据通信</span><br><span class="line">REST架构对资源的操作CRTUD的操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法</span><br><span class="line">RPC远程方法调用，就是像调用本地方法一样调用远程方法</span><br></pre></td></tr></table></figure><p><img src="/blog/2019/11/26/SpringCloud基础/RPC与REST.png" alt="RPC和REST区别"></p><h4 id="微服务通信方式？"><a href="#微服务通信方式？" class="headerlink" title="微服务通信方式？"></a>微服务通信方式？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.RestTemplate</span><br><span class="line">（1）restTemplate.getForObject(&quot;http://localhost:8773/hi&quot;,String.class);</span><br><span class="line">（2）loadBalancerClient</span><br><span class="line">（3）server_id服务调用</span><br><span class="line">2.远程调用，比如feign接口调用，直接通过远程过程调用来访问别的service。</span><br><span class="line">3.消息中间件rabbitmq</span><br></pre></td></tr></table></figure><h4 id="Eureka和Zookeeper区别"><a href="#Eureka和Zookeeper区别" class="headerlink" title="Eureka和Zookeeper区别?"></a>Eureka和Zookeeper区别?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Eureka取CAP的AP，注重可用性，Zookeeper取CAP的CP注重一致性</span><br><span class="line">2.Zookeeper在选举期间注册服务瘫痪，虽然服务最终会恢复，但选举期间不可用</span><br><span class="line">3.eureka的自我保护机制，会导致一个结果就是不会再从注册列表移除因长时间没收到心跳而过期的服务。依然能接受新服务的注册和查询请求，但不会被同步到其他节点。不会服务瘫痪</span><br><span class="line">4.Zookeeper有Leader和Follower角色，Eureka各个节点平等</span><br><span class="line">5.Zookeeper采用过半数存活原则，Eureka采用自我保护机制解决分区问题</span><br><span class="line">6.eureka本质是一个工程，Zookeeper只是一个进程</span><br></pre></td></tr></table></figure><h4 id="Eureka和Zookeeper中CAP区别？"><a href="#Eureka和Zookeeper中CAP区别？" class="headerlink" title="Eureka和Zookeeper中CAP区别？"></a>Eureka和Zookeeper中CAP区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CAP理论</span><br><span class="line">1.C（Consistency）：数据一致性</span><br><span class="line">2.A（Availability）：可用性</span><br><span class="line">3.P（Partition Tolerance）：分区容错性</span><br><span class="line">当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，单不能接受服务直接down掉不可用,服务注册功能对可用性的要求要高于一致性</span><br><span class="line">Eureka看明白了这点，因此在设计师就有限保证可用性，Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时如果发现连接失败，会自动切换至其他节点，只要有一台Eureka还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证强一致性）,Eureka还有一种自我保护机制</span><br><span class="line">Eureka基于AP原则，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像Zookeeper 那样使整个注册服务瘫痪</span><br><span class="line">Zookeeper基于CP原则，不是强一致的，并且选举时间在30-120秒在选举期间集群不可用，服务瘫痪</span><br><span class="line">作为注册中心，最主要得到就是保证可用性，可以接受短时间内数据不一致的情况</span><br><span class="line">个人觉得Eureka做i为单纯的服务注册中心来说比Zookeeper更专业一点</span><br></pre></td></tr></table></figure><h4 id="Eureka的自我保护机制？"><a href="#Eureka的自我保护机制？" class="headerlink" title="Eureka的自我保护机制？"></a>Eureka的自我保护机制？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障</span><br><span class="line">当Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，保护注册信息，不再删除注册数据，故障恢复时，自动退出自我保护模式。</span><br><span class="line">1、Eureka不再从注册列表中溢出因为长时间没有收到心跳而应该过期的服务</span><br><span class="line">2、Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点依然可用）</span><br><span class="line">3、当网络稳定是，当前实例新的注册信息会被同步到其他节点中</span><br><span class="line">因此，Eureka可以很好的应对网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪</span><br></pre></td></tr></table></figure><h4 id="Ribbon和Feign的区别？"><a href="#Ribbon和Feign的区别？" class="headerlink" title="Ribbon和Feign的区别？"></a>Ribbon和Feign的区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Ribbon都是调用其他服务的，但方式不同</span><br><span class="line">2.启动类注解不同，Ribbon是@RibbonClient feign的是@EnableFeignClients</span><br><span class="line">3.服务指定的位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明</span><br><span class="line">4.调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用的方法定义成抽象方法即可</span><br></pre></td></tr></table></figure><h4 id="什么是Spring-Cloud-Bus"><a href="#什么是Spring-Cloud-Bus" class="headerlink" title="什么是Spring Cloud Bus?"></a>什么是Spring Cloud Bus?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring cloud bus </span><br><span class="line">将分布式的节点用轻量的消息代理连接起来，可用于广播配置文件的更改或者服务直接的通讯和监控</span><br><span class="line">如果修改了配置文件，发送一次请求，所有的客户端便会重新读取配置文件</span><br></pre></td></tr></table></figure><h4 id="springcloud断路器作用"><a href="#springcloud断路器作用" class="headerlink" title="springcloud断路器作用?"></a>springcloud断路器作用?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）</span><br><span class="line">打开:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务</span><br><span class="line">半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭</span><br><span class="line">关闭：当服务一直处于正常状态 能正常调用</span><br></pre></td></tr></table></figure><h4 id="什么是SpringCloudConfig"><a href="#什么是SpringCloudConfig" class="headerlink" title="什么是SpringCloudConfig?"></a>什么是SpringCloudConfig?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件</span><br><span class="line">在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中</span><br><span class="line">在spring cloud config 组件中，分两个角色，一是config server，二是config client</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SpringCloud基础&quot;&gt;&lt;a href=&quot;#SpringCloud基础&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud基础&quot;&gt;&lt;/a&gt;SpringCloud基础&lt;/h3&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="https://lastsummer.top/blog/categories/SpringCloud/"/>
    
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/tags/JAVA/"/>
    
      <category term="SpringBoot" scheme="https://lastsummer.top/blog/tags/SpringBoot/"/>
    
      <category term="SpringCloud" scheme="https://lastsummer.top/blog/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令详解</title>
    <link href="https://lastsummer.top/blog/2019/11/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lastsummer.top/blog/2019/11/26/Linux常用命令详解/</id>
    <published>2019-11-26T01:54:23.000Z</published>
    <updated>2019-11-27T06:08:02.243Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux常用命令详解"><a href="#Linux常用命令详解" class="headerlink" title="Linux常用命令详解"></a>Linux常用命令详解</h3><a id="more"></a><h4 id="关机及重启"><a href="#关机及重启" class="headerlink" title="关机及重启"></a>关机及重启</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now 立刻关机</span><br><span class="line">shutdown -h 5 5分钟后关机</span><br><span class="line">poweroff 立刻关机</span><br><span class="line"></span><br><span class="line">shutdown -r now</span><br><span class="line">shutdown -r 5 5分钟后重启</span><br><span class="line">reboot 立刻重启</span><br></pre></td></tr></table></figure><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown --help：</span><br><span class="line">ifconfig  --help：查看网卡信息</span><br></pre></td></tr></table></figure><h4 id="目录操作指令"><a href="#目录操作指令" class="headerlink" title="目录操作指令"></a>目录操作指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cd 切换目录</span><br><span class="line">ls 目录查看</span><br><span class="line">mkdir aaa 创建目录</span><br><span class="line">rm -f aaa 删除当前目录下的aaa目录（不询问）</span><br><span class="line">rm -r aaa 递归删除当前下的aaa目录</span><br><span class="line">rm -rf aaa 递归删除当前目录下的aaa目录（不询问，谨慎使用，避免全部删除）</span><br><span class="line">rm可以删除文件、目录、压缩包、</span><br><span class="line">mv 移动文件或者重命名文件或目录</span><br><span class="line">cp -r 目录名称 目录拷贝的目标位置   -r代表递归</span><br><span class="line">find 目录 参数 文件名称 搜索目录 find /usr/tmp -name &apos;a*&apos; </span><br><span class="line">touch aaa.txt 创建文件</span><br><span class="line">pwd 查看当前目录</span><br><span class="line">vim及vi编辑器命令模式底行模式及插入模式</span><br><span class="line">cat 文件的查看 看最后一屏</span><br><span class="line">more 百分比查看</span><br><span class="line">less 翻页查看</span><br><span class="line">head 显示文件头数据</span><br><span class="line">tail 指定行数或者动态查看</span><br><span class="line">echo 创建带有内容的文件</span><br></pre></td></tr></table></figure><h4 id="安装下载解压操作"><a href="#安装下载解压操作" class="headerlink" title="安装下载解压操作"></a>安装下载解压操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum 应用市场安装</span><br><span class="line">wegt 加地址 表示下载</span><br><span class="line">tar -zvxf</span><br><span class="line">-A 新增文件到已压缩文件中</span><br><span class="line">-c 新建新压缩文件</span><br><span class="line">-r 将新文件添加到已压缩文件的末尾</span><br><span class="line">-x 解压缩文件</span><br><span class="line">-k 保留原压缩文件</span><br><span class="line">-f 待压缩或待解压缩文件</span><br><span class="line">-j bzip2格式</span><br><span class="line">-z gzip格式</span><br><span class="line">-v 显示过程</span><br></pre></td></tr></table></figure><h4 id="权限修改"><a href="#权限修改" class="headerlink" title="权限修改"></a>权限修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chmod</span><br><span class="line">权限分为三种：读（r=4），写（w=2），执行（x=1）</span><br><span class="line">可读可执行 rx=5=4+1</span><br><span class="line">可读可写 rw=6=4+2</span><br><span class="line">可执行可写 wx=3=2+1</span><br><span class="line">可读可写可执行 rwx=7=4+1+2</span><br><span class="line">常用数字权限</span><br><span class="line">-rw------- (600) 只有拥有者有读写权限。</span><br><span class="line">-rw-r--r-- (644) 只有拥有者有读写权限；而属组用户和其他用户只有读权限。</span><br><span class="line">-rwx------ (700) 只有拥有者有读、写、执行权限。</span><br><span class="line">-rwxr-xr-x (755) 拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。</span><br><span class="line">-rwx--x--x (711) 拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。</span><br><span class="line">-rw-rw-rw- (666) 所有用户都有文件读、写权限。</span><br><span class="line">-rwxrwxrwx (777) 所有用户都有读、写、执行权限。</span><br><span class="line">创建sh文件后需要赋予可执行权限</span><br></pre></td></tr></table></figure><h4 id="进程命令"><a href="#进程命令" class="headerlink" title="进程命令"></a>进程命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java 查看进程</span><br><span class="line">su 默认切换root用户</span><br><span class="line">ps -ef 查看所有正在运行的进程</span><br><span class="line">kill pid 杀死进程</span><br><span class="line">kill -9 pid 强制杀死进程</span><br><span class="line">ifconfig 查看你网卡信息</span><br><span class="line">ping 查看与某台机器的连接情况</span><br><span class="line">netstat 显示网络状态信息</span><br><span class="line">netstat -an 查看当前系统接口</span><br><span class="line">netstat -an | grep 8080 搜索指定端口8080</span><br><span class="line">clear 清屏</span><br><span class="line">usermod 修改用户</span><br><span class="line">useradd 添加用户</span><br><span class="line">userdel 删除用户</span><br><span class="line">passwd 修改密码</span><br><span class="line">groupadd 添加用户组</span><br><span class="line">groupmod 修改用户组</span><br><span class="line">groupdel 删除用户组</span><br></pre></td></tr></table></figure><h4 id="环境变量路径配置"><a href="#环境变量路径配置" class="headerlink" title="环境变量路径配置"></a>环境变量路径配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile java环境变量</span><br><span class="line">/etc/sysconfig/network-scripts/ifcfg-eno 网卡配置</span><br><span class="line">source /etc/profile 刷新环境变量</span><br><span class="line">uname -a 查看系统版本</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux常用命令详解&quot;&gt;&lt;a href=&quot;#Linux常用命令详解&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令详解&quot;&gt;&lt;/a&gt;Linux常用命令详解&lt;/h3&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://lastsummer.top/blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://lastsummer.top/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java代理模式</title>
    <link href="https://lastsummer.top/blog/2019/11/14/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lastsummer.top/blog/2019/11/14/Java代理模式/</id>
    <published>2019-11-14T05:50:03.000Z</published>
    <updated>2019-11-22T04:31:53.985Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java代理模式"><a href="#Java代理模式" class="headerlink" title="Java代理模式"></a>Java代理模式</h3><a id="more"></a><p>代理模式主要为其他对象提供一种代理以控制这个对象的访问。在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，好比你将一些繁琐的事情交给第三方去管理，那么第三方就是你的代理，其他人只会去找这个代理，而不会去找你，<b>AOP本身就是基于动态代理实现的</b>，所以掌握了代理模式对AOP的学习很有帮助的哦。<br><b>代理模式的三种种实现方式(静态代理、jdk动态代理、CGLib代理)</b></p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>代理类在程序运行前就已经存在,那么这种代理方式被成为静态代理(接口、实现类、代理类都存在)</p><h4 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h4><p>代理类在程序运行时创建的代理方式被称为 动态代理<br>如果目标对象实现了接口,采用JDK的动态代理(接口、实现类存在，代理类运行后创建)<br>如果目标对象没有实现接口,必须采用cglib动态代理(实现类，代理类运行后创建)</p><h4 id="CGLib代理"><a href="#CGLib代理" class="headerlink" title="CGLib代理"></a>CGLib代理</h4><p>目标类不能为final,目标对象的方法如果为final / static，那么就不会被拦截，即不会执行目标对象额外的业务方法</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>静态代理：<br>(1)可以做到在不修改目标对象的功能前提下,对目标功能扩展<br>(2)代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护<br>JDK动态代理:<br>(1)代理对象不需要实现接口, 利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)<br>(2)目标对象一定要实现接口,否则不能用动态代理<br>CGLib代理:<br>(1)静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象类实现代理</p><p>JDK动态代理使用Java的反射技术生成代理类，只能代理实现了接口的类，没有实现接口的类不能实现动态代理，CGLib会在运行时动态的生成一个被代理类的子类，子类重写了被代理类中所有非final的方法，在子类中采用方法拦截的技术拦截所有父类方法的调用，不需要被代理类对象实现接口，从而CGLIB动态代理效率比Jdk动态代理反射技术效率要高</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java代理模式&quot;&gt;&lt;a href=&quot;#Java代理模式&quot; class=&quot;headerlink&quot; title=&quot;Java代理模式&quot;&gt;&lt;/a&gt;Java代理模式&lt;/h3&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://lastsummer.top/blog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java8中抽象类与接口的异同</title>
    <link href="https://lastsummer.top/blog/2019/11/06/Java8%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%82%E5%90%8C/"/>
    <id>https://lastsummer.top/blog/2019/11/06/Java8中抽象类与接口的异同/</id>
    <published>2019-11-06T10:37:28.000Z</published>
    <updated>2019-11-06T10:47:32.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-8中抽象类与接口的异同"><a href="#Java-8中抽象类与接口的异同" class="headerlink" title="Java 8中抽象类与接口的异同"></a>Java 8中抽象类与接口的异同</h3><a id="more"></a><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)都是抽象类型；</span><br><span class="line">(2)都可以有实现方法（以前接口不行）；</span><br><span class="line">(3)都可以不需要实现类或者继承者去实现所有方法,以前不行，现在接口中默认方法不需要实现者实现</span><br></pre></td></tr></table></figure><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）；</span><br><span class="line">(2)抽象类和接口所反映出的设计理念不同。</span><br><span class="line">  其实抽象类表示的是&quot;is-a&quot;关系，接口表示的是&quot;like-a&quot;关系；</span><br><span class="line">(3)接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值；</span><br><span class="line">  抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。</span><br></pre></td></tr></table></figure><h4 id="接口实例"><a href="#接口实例" class="headerlink" title="接口实例"></a>接口实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public interface InterfaceClass &#123;</span><br><span class="line"></span><br><span class="line">//接口中的常量定义（必须为其赋值）</span><br><span class="line">public static final String s = &quot;1&quot;;</span><br><span class="line"></span><br><span class="line">//抽象方法的定义（没有具体的实现）</span><br><span class="line">public abstract void query();</span><br><span class="line"></span><br><span class="line">//没有构造方法</span><br><span class="line"></span><br><span class="line">//java8新增的默认方法(默认方法实现类可以实现也可以不实现，不实现也能直接调用接口的默认方法)</span><br><span class="line">default void default1() &#123;</span><br><span class="line">System.out.println(&quot;测试默认方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    //默认方法的重载</span><br><span class="line">    default  void default1(String a) &#123;</span><br><span class="line">        System.out.println(&quot;测试默认方法111&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //包含方法的实现的静态方法（实现类不能重写此方法）</span><br><span class="line">static String static1() &#123;</span><br><span class="line">System.out.println(&quot;这是一个静态的方法！！！&quot;);</span><br><span class="line">return &quot;这是一个静态的方法！！！&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">testInterface test = new testInterface();</span><br><span class="line">System.out.println(test.s);</span><br><span class="line">test.default1();</span><br><span class="line">test.default1(&quot;ss&quot;);</span><br><span class="line">System.out.println(InterfaceClass.s);</span><br><span class="line">System.out.print(InterfaceClass.static1());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class testInterface implements InterfaceClass&#123;</span><br><span class="line">@Override</span><br><span class="line">public void query() &#123;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void default1() &#123;</span><br><span class="line">System.out.println(&quot;子类自我实现默认方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void default1(String a) &#123;</span><br><span class="line">InterfaceClass.super.default1(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象实例"><a href="#抽象实例" class="headerlink" title="抽象实例"></a>抽象实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">//构造代码块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static&#123;</span><br><span class="line">//可以有静态代码块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象类中变量的定义，默认为friendly类型，默认类型，只允许包内访问</span><br><span class="line">String s = &quot;1&quot;;</span><br><span class="line"></span><br><span class="line">//可以有构造方法</span><br><span class="line">public AbstractClass() &#123;&#125;</span><br><span class="line"></span><br><span class="line">//抽象方法使用public abstract、protected abstract、abstract修饰</span><br><span class="line">public abstract void query();</span><br><span class="line">protected abstract void query1();</span><br><span class="line">abstract void query2();</span><br><span class="line"></span><br><span class="line">//包含普通方法</span><br><span class="line">public void ss() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class testAbstract extends AbstractClass&#123;</span><br><span class="line">@Override</span><br><span class="line">public void query() &#123;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void query1() &#123;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void query2() &#123;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void ss() &#123;</span><br><span class="line">super.ss();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java-8中抽象类与接口的异同&quot;&gt;&lt;a href=&quot;#Java-8中抽象类与接口的异同&quot; class=&quot;headerlink&quot; title=&quot;Java 8中抽象类与接口的异同&quot;&gt;&lt;/a&gt;Java 8中抽象类与接口的异同&lt;/h3&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://lastsummer.top/blog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础面试题四</title>
    <link href="https://lastsummer.top/blog/2019/10/10/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9B/"/>
    <id>https://lastsummer.top/blog/2019/10/10/JAVA基础面试题四/</id>
    <published>2019-10-10T05:57:01.000Z</published>
    <updated>2019-10-16T08:53:40.640Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本文主要JAVA基础面试题四"><a href="#本文主要JAVA基础面试题四" class="headerlink" title="本文主要JAVA基础面试题四"></a>本文主要JAVA基础面试题四</h3><a id="more"></a><h4 id="Class-forName的作用-为什么要用"><a href="#Class-forName的作用-为什么要用" class="headerlink" title="Class.forName的作用?为什么要用?"></a>Class.forName的作用?为什么要用?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;&quot;)返回的是类</span><br><span class="line">Class.forName(&quot;&quot;).newInstance()返回的是object</span><br><span class="line">A a = (A)Class.forName(&quot;pacage.A&quot;).newInstance(); </span><br><span class="line">动态加载和创建Class 对象，比如想根据用户输入的字符串来创建对象。</span><br><span class="line">jvm会执行静态代码段，你要记住一个概念，静态代码是和class绑定的，class装载成功就表示执行了你的静态代码了。而且以后不会再走这段静态代码了。</span><br><span class="line">第一是CLASSPATH下指定名字的.class文件加载到Java虚拟机内存中</span><br><span class="line">第二是初始化这个类</span><br><span class="line">一.首先你要明白在java里面任何class都要装载在虚拟机上才能运行。</span><br><span class="line"> 1.forName这句话就是装载类用的(new是根据加载到内存中的类创建一个实例，要分清楚)。 </span><br><span class="line"> 2.至于什么时候用，可以考虑一下这个问题，给你一个字符串变量，它代表一个类的包名和类名，你怎么实例化它？</span><br><span class="line"> A a = (A)Class.forName(&quot;pacage.A&quot;).newInstance();这和 A a =new A();是一样的效果。</span><br><span class="line"> 3.jvm在装载类时会执行类的静态代码段，要记住静态代码是和class绑定的，class装载成功就表示执行了你的静态代码了，而且以后不会再执行这段静态代码了。</span><br><span class="line"> 4.Class.forName(xxx.xx.xx)的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。</span><br><span class="line"> 5. 动态加载和创建Class 对象，比如想根据用户输入的字符串来创建对象</span><br><span class="line">二.在初始化一个类，生成一个实例的时候，newInstance()方法和new关键字除了一个是方法，一个是关键字外，最主要有什么区别？</span><br><span class="line"> 1.它们的区别在于创建对象的方式不一样，前者是使用类加载机制，后者是创建一个新类。</span><br><span class="line"> 2.那么为什么会有两种创建对象方式？</span><br><span class="line"> 这主要考虑到软件的可伸缩、可扩展和可重用等软件设计思想。 </span><br><span class="line"> 3.从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。 但是使用newInstance()方法的时候，必须保证这个类已经加载且这个类已经连接了。</span><br><span class="line">三.最后用最简单的描述来区分new关键字和newInstance()方法的区别： </span><br><span class="line"> 1. newInstance: 弱类型。低效率。只能调用无参构造。 </span><br><span class="line"> 2. new: 强类型。相对高效。能调用任何public构造。</span><br></pre></td></tr></table></figure><h4 id="Servlet介绍？-单例多线程"><a href="#Servlet介绍？-单例多线程" class="headerlink" title="Servlet介绍？(单例多线程)"></a>Servlet介绍？(单例多线程)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">servlet的生命周期由servlet容器控制，该容器创建servlet的实例。servlet的生命周期就是指servlet实例在创建之后响应客户端请求直至销毁的全过程。</span><br><span class="line">servlet实例的首次创建取决于servlet的首次调用。servlet接口定义了servlet生命周期的三个方法，这些方法就是init(),service(),destroy().</span><br><span class="line">（1）init()方法用来把servlet导入和初始化。这个方法在servlet被预加载或在第一次请求时执行。</span><br><span class="line">（2）servlet处理0个或多个请求。servlet对每个方法都用service()方法来处理。</span><br><span class="line">（3）当web应用声明servlet被关闭、servlet被销毁、垃圾收集器对资源进行收集时，用destroy()方法来关闭servlet。    </span><br><span class="line">高并发、不安全</span><br><span class="line">只存在一个servlet、多个线程同时请求实例变量、非线程安全</span><br><span class="line">如何做到线程安全？</span><br><span class="line">1.实现SingleThreadModel接口</span><br><span class="line">2.synchronized关键字加锁lock</span><br><span class="line">3.尽量不使用实例变量</span><br></pre></td></tr></table></figure><h4 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java语言中关键字 volatile 被称作轻量级的 synchronized</span><br><span class="line">用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最新的值。</span><br><span class="line">volatile很容易被误用，用来进行原子性操作，它不能保证多个线程修改的安全性。</span><br><span class="line">Java可以使用volatile关键字，确保每个线程对本地变量的访问和修改都直接与主内存交互，而不是与本地线程的工作内存交互的，保证每个线程都能获得最新的值。</span><br></pre></td></tr></table></figure><p><img src="/blog/2019/10/10/JAVA基础面试题四/java1.png" alt=""></p><h4 id="和equals的区别？"><a href="#和equals的区别？" class="headerlink" title="==和equals的区别？"></a>==和equals的区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)对于==，比较的是值是否相等</span><br><span class="line"> 如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</span><br><span class="line"> 如果作用于引用类型的变量，则比较的是所指向的对象的地址</span><br><span class="line">(2)对于equals方法，注意：equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象</span><br><span class="line"> 如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</span><br><span class="line"> 诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</span><br></pre></td></tr></table></figure><h4 id="数组有没有length-方法？string没有lenght-方法？"><a href="#数组有没有length-方法？string没有lenght-方法？" class="headerlink" title="数组有没有length()方法？string没有lenght()方法？"></a>数组有没有length()方法？string没有lenght()方法？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据没有length()，但有length属性</span><br><span class="line">string有length()方法</span><br></pre></td></tr></table></figure><h4 id="服务代理后获取真实ip地址"><a href="#服务代理后获取真实ip地址" class="headerlink" title="服务代理后获取真实ip地址"></a>服务代理后获取真实ip地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java获取客户端IP地址的方法为request.getRemoteAddr()。</span><br><span class="line">request.getHeader(&quot;x-forwarded-for&quot;)</span><br><span class="line">request.getHeader(&quot;Proxy-Client-IP&quot;)</span><br><span class="line">request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br></pre></td></tr></table></figure><h4 id="Oracle和Mysql的区别"><a href="#Oracle和Mysql的区别" class="headerlink" title="Oracle和Mysql的区别"></a>Oracle和Mysql的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、关系型数据库</span><br><span class="line">2、Oracle收费、Mysql开源</span><br><span class="line">3、Oracle一个实例对应多个用户</span><br><span class="line">  Mysql一个用户对应多个数据库</span><br><span class="line">4、与Oracle相比，MySQL没有表空间，角色管理，快照，同义词和包以及自动存储管理。</span><br></pre></td></tr></table></figure><h4 id="Vue和JQuery区别"><a href="#Vue和JQuery区别" class="headerlink" title="Vue和JQuery区别"></a>Vue和JQuery区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、Vue比JQuery减少了 DOM 操作</span><br><span class="line">2、Vue支持双向数据绑定及组件化</span><br><span class="line">3、jquery 是javacript库，封装了一些js常用的方法。（动态效果）</span><br><span class="line">  vue 是一个前端框架，vue有成熟的生态链，mvvm模式，是一个真正的web框架（单页面开发）。</span><br></pre></td></tr></table></figure><h4 id="JWT和Token区别"><a href="#JWT和Token区别" class="headerlink" title="JWT和Token区别"></a>JWT和Token区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">token一个字符串。每次客户端保存localstore，每次请求放入到http head请求头中进行访问（Bearer），服务器查询数据库验证信息是否正确</span><br><span class="line">相同： </span><br><span class="line">都是访问资源的令牌， 都可以记录用户信息，都是只有验证成功后</span><br><span class="line">区别：</span><br><span class="line">​服务端验证客户端发来的token信息要进行数据的查询操作；</span><br><span class="line">JWT验证客户端发来的token信息就不用， 在服务端使用密钥校验就可以，不用数据库的查询。</span><br><span class="line">JWT（请求头【类型jwt+hs256算法加密】、载荷【预定义声明+自定义声明userid+签名】、签名）</span><br><span class="line">base64请求头+base64载荷+签名【(base64请求头+base64载荷)hash算法】组成两个点的字符串（secret解密）</span><br></pre></td></tr></table></figure><h4 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动jar包</span><br><span class="line">nginx日志切割</span><br></pre></td></tr></table></figure><h4 id="Git冲突处理方案"><a href="#Git冲突处理方案" class="headerlink" title="Git冲突处理方案"></a>Git冲突处理方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当Git merge无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</span><br><span class="line">把修改的文件复制出来、先pull在修改。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本文主要JAVA基础面试题四&quot;&gt;&lt;a href=&quot;#本文主要JAVA基础面试题四&quot; class=&quot;headerlink&quot; title=&quot;本文主要JAVA基础面试题四&quot;&gt;&lt;/a&gt;本文主要JAVA基础面试题四&lt;/h3&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://lastsummer.top/blog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Web相关优化</title>
    <link href="https://lastsummer.top/blog/2019/10/09/Web%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/"/>
    <id>https://lastsummer.top/blog/2019/10/09/Web相关优化/</id>
    <published>2019-10-09T01:24:13.000Z</published>
    <updated>2019-10-16T07:55:20.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Web相关优化"><a href="#Web相关优化" class="headerlink" title="Web相关优化"></a>Web相关优化</h3><a id="more"></a><h4 id="表现层页面的优化"><a href="#表现层页面的优化" class="headerlink" title="表现层页面的优化"></a>表现层页面的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">尽量使用静态HTML页面</span><br><span class="line">不使用FLASH、图片</span><br><span class="line">尽量使用DIV、不将整个页面放入TABLE中</span><br><span class="line">将javascript放入到js文件中</span><br><span class="line">使用IFrame嵌套另一个页面，和主页面分开加载，不影响页面加载速度</span><br><span class="line">CSS放在头部、JS脚本放在底部加载</span><br><span class="line">对于访问量高的页面，设计缓存方案，经常访问的数据缓存起来</span><br><span class="line">优化重要的公共模块、高度集成提示信息</span><br></pre></td></tr></table></figure><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis分布式缓存</span><br><span class="line">ehcache、oscache缓存</span><br><span class="line">hibernate二级缓存</span><br><span class="line">前端静态js、css、样式文件缓存</span><br></pre></td></tr></table></figure><h4 id="数据库的优化"><a href="#数据库的优化" class="headerlink" title="数据库的优化"></a>数据库的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据库的优化(读写分离、分区、分表、缓存、索引、视图、存储过程等)</span><br><span class="line">sql优化</span><br></pre></td></tr></table></figure><h4 id="服务器的优化"><a href="#服务器的优化" class="headerlink" title="服务器的优化"></a>服务器的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">外部环境优化：</span><br><span class="line">（1）java虚拟机的优化、尽量采用最新的版本、设置java虚拟机的内存参数</span><br><span class="line">服务器自身的优化：</span><br><span class="line">（1）Tomcat 例如：设置线程数量、JSP编译速度、防止恶意攻击、压缩</span><br><span class="line"> 1、优化Tomcat的JVM环境内存优化</span><br><span class="line">2、优化tomcat线程池</span><br><span class="line">3、禁用DNS查询 enableLookups=&quot;false&quot;</span><br><span class="line">4、session过期时间</span><br><span class="line">5、Apr插件提高Tomcat性能</span><br><span class="line">6、压缩</span><br><span class="line">7、文字转码UTF-8</span><br><span class="line">（2）Nginx </span><br><span class="line">1、expires缓存模块、网页缓存</span><br><span class="line">2、gzip压缩模块</span><br><span class="line">3、隐藏版本号</span><br><span class="line">4、日志切割</span><br><span class="line">5、设置连接超时、进程数、配置防盗链</span><br><span class="line">6、动静分离</span><br><span class="line">7、代理http跳转https这块配置  </span><br><span class="line">8、nginx添加用户组</span><br><span class="line">9、最多可以打开文件数</span><br></pre></td></tr></table></figure><h4 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">负载均衡：</span><br><span class="line">是大型网站解决高负荷访问和大量并发请求采用的最终解决办法</span><br><span class="line">与图片服务器分离：</span><br><span class="line">设置独立的图片服务器，可以降低web应用的服务器的压力，保证系统不会因为图片问题二奔溃(优化)</span><br></pre></td></tr></table></figure><h4 id="减少外部http协议"><a href="#减少外部http协议" class="headerlink" title="减少外部http协议"></a>减少外部http协议</h4><h4 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。</span><br><span class="line">简单的来说，就是把原服务器上数据复制到其他服务器上，用户访问时，那台服务器近访问到的就是那台服务器上的数据。CDN加速优点是成本低，速度快。适合访问量比较大的网站。</span><br></pre></td></tr></table></figure><h4 id="echarts简单优化？"><a href="#echarts简单优化？" class="headerlink" title="echarts简单优化？"></a>echarts简单优化？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">模块复用</span><br><span class="line">缓存</span><br><span class="line">关闭动画（3D）</span><br><span class="line">SQL优化</span><br><span class="line">可选择 dataZoom</span><br><span class="line">type为line时可选择sampling</span><br><span class="line">懒加载（逐步加载）echarts模块或图片lazyload</span><br><span class="line">清理不用的图表、clear和dispose</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Web相关优化&quot;&gt;&lt;a href=&quot;#Web相关优化&quot; class=&quot;headerlink&quot; title=&quot;Web相关优化&quot;&gt;&lt;/a&gt;Web相关优化&lt;/h3&gt;
    
    </summary>
    
      <category term="WEB" scheme="https://lastsummer.top/blog/categories/WEB/"/>
    
    
      <category term="web" scheme="https://lastsummer.top/blog/tags/web/"/>
    
  </entry>
  
</feed>
