<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>去年夏天</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://lastsummer.top/blog/"/>
  <updated>2020-02-29T15:52:38.231Z</updated>
  <id>https://lastsummer.top/blog/</id>
  
  <author>
    <name>Wang Rui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker自定义redis镜像</title>
    <link href="https://lastsummer.top/blog/2020/02/29/Docker%E8%87%AA%E5%AE%9A%E4%B9%89redis%E9%95%9C%E5%83%8F/"/>
    <id>https://lastsummer.top/blog/2020/02/29/Docker自定义redis镜像/</id>
    <published>2020-02-29T15:35:26.000Z</published>
    <updated>2020-02-29T15:52:38.231Z</updated>
    
    <content type="html"><![CDATA[<p>Docker自定义redis镜像。<a id="more"></a></p><h3 id="DockerFile配置"><a href="#DockerFile配置" class="headerlink" title="DockerFile配置"></a>DockerFile配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER wangrui&lt;15034005712@163.com&gt;</span><br><span class="line"></span><br><span class="line">RUN yum -y install gcc make pcre-devel zlib-devel tar zlib</span><br><span class="line"></span><br><span class="line">ADD redis-4.0.8.tar.gz /usr/src/</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line"># redis配置</span><br><span class="line">RUN cd /usr/src/redis-4.0.8 &amp;&amp; make &amp;&amp; make install PREFIX=/usr/local/redis</span><br><span class="line">RUN cd /usr/local/redis</span><br><span class="line">COPY redis.conf /usr/local/redis/redis.conf</span><br><span class="line">RUN rm -rf /usr/src/redis-4.0.8</span><br><span class="line"></span><br><span class="line"># 容器卷（持久化数据到宿主机）</span><br><span class="line">VOLUME [&quot;/docker/redis/&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line"></span><br><span class="line">CMD [&quot;/usr/local/redis/bin/redis-server&quot;,&quot;/usr/local/redis/redis.conf&quot;]</span><br></pre></td></tr></table></figure><h3 id="redis-conf配置"><a href="#redis-conf配置" class="headerlink" title="redis.conf配置"></a>redis.conf配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）注释掉bind 127.0.0.1（外网访问）</span><br><span class="line">（2）添加daemonize no（解决启动报错）</span><br><span class="line">（3）修改protected-mode yes-&gt;no（外网访问）</span><br><span class="line">（4）添加requirepass yourpassword（自定义auth密码）</span><br><span class="line">（5）dir /docker/redis/（容器卷持久化redis数据到宿主机）可选</span><br><span class="line">（6）logfile &quot;/docker/redis/redis.log&quot;（容器卷持久化日志到宿主机）可选</span><br></pre></td></tr></table></figure><h3 id="Docker指令"><a href="#Docker指令" class="headerlink" title="Docker指令"></a>Docker指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker build -f ./Dockerfile it redis .</span><br><span class="line">docker run -d -p 6379:6379 redis</span><br><span class="line"># 获取容器/镜像的元数据。</span><br><span class="line">docker inspect 容器ID</span><br><span class="line"># 删除镜像</span><br><span class="line">docker rmi -f redis</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker自定义redis镜像。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://lastsummer.top/blog/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://lastsummer.top/blog/tags/Docker/"/>
    
      <category term="Redis" scheme="https://lastsummer.top/blog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="https://lastsummer.top/blog/2020/02/19/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://lastsummer.top/blog/2020/02/19/Docker常用命令/</id>
    <published>2020-02-19T12:22:04.000Z</published>
    <updated>2020-02-19T12:53:27.749Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 常用命令。<a id="more"></a></p><h3 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 搜索Docker Hub中的镜像</span><br><span class="line">docker search java</span><br><span class="line"># 从Docker Hub下载最新的java</span><br><span class="line">docker pull java</span><br><span class="line"># Docker Registry地址/仓库/镜像名称:标签</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/wangrui15034005712/nginx</span><br><span class="line"># 列出本地所有镜像，默认过滤中间映像层</span><br><span class="line">docker images -a</span><br><span class="line"># 删除指定镜像</span><br><span class="line">docker rmi -f [镜像名称]</span><br><span class="line"># 删除全部镜像</span><br><span class="line">docker rmi -f $(docker images)</span><br><span class="line"># 构建镜像 -t 设置签名</span><br><span class="line">docker build -t nginx:wr .</span><br><span class="line"># 启动容器 -d 后台启动，并打印容器ID -p 指定映射端口</span><br><span class="line">docker run -d -p 8080:8080 nginx:wr</span><br><span class="line"># 累出运行中的容器 -a 列出所有容器（包括未运行容器）</span><br><span class="line">docker ps -a</span><br><span class="line"># 停止容器</span><br><span class="line">docker stop 容器ID</span><br><span class="line"># 强制停止容器</span><br><span class="line">docker kill 容器ID</span><br><span class="line"># 启动已停止的容器</span><br><span class="line">docker statr 容器ID</span><br><span class="line"># 重新启动容器</span><br><span class="line">docker restatr 容器ID</span><br><span class="line"># 进入容器</span><br><span class="line">docker attach 容器ID</span><br><span class="line"># 删除容器指定容器</span><br><span class="line">docker rm [容器ID]</span><br><span class="line"># 删除全部容器 -q 只展示容器ID</span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br><span class="line"># 将指定容器导出tar包 --output将内容写入文件而非标准输出</span><br><span class="line">docker export 容器名称 &gt; app.tar</span><br><span class="line">docker export --output &gt; app.tar</span><br><span class="line"># 引入容器并创建nginx镜像</span><br><span class="line">docker import app.tar nginx</span><br><span class="line"># 保存镜像</span><br><span class="line">docker save 容器名称 &gt; app.tar</span><br><span class="line">docker save --output app.tar 容器名称</span><br><span class="line"># 加载镜像 --input 从文件加载而非标准输入</span><br><span class="line">docker load &lt; app.tar</span><br><span class="line">docker load --input app.tar</span><br><span class="line"># docker Hub注册后才可登录</span><br><span class="line">docker login</span><br><span class="line"># 推送镜像</span><br><span class="line">docker push wangrui/nginx:wr</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 常用命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://lastsummer.top/blog/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://lastsummer.top/blog/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Mysql基础函数及行转列</title>
    <link href="https://lastsummer.top/blog/2020/02/18/Mysql%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0%E5%8F%8A%E8%A1%8C%E8%BD%AC%E5%88%97/"/>
    <id>https://lastsummer.top/blog/2020/02/18/Mysql基础函数及行转列/</id>
    <published>2020-02-18T12:17:18.000Z</published>
    <updated>2020-02-18T13:07:46.405Z</updated>
    
    <content type="html"><![CDATA[<p>MYSQL借用<b>mysql.help_topic</b>生成连续的日期。<br><b>mysql.help_topic</b>是一个从0开始到506的一个序列组（列转行、生成连续日期等）。<br><a id="more"></a></p><h3 id="生成连续的日期"><a href="#生成连续的日期" class="headerlink" title="生成连续的日期"></a>生成连续的日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  date_format(date_add(SYSDATE(),INTERVAL-t.help_topic_id DAY),&apos;%Y-%m-%d&apos;) </span><br><span class="line">FROM</span><br><span class="line">  mysql.help_topic t </span><br><span class="line">WHERE</span><br><span class="line">  t.help_topic_id &lt; 10</span><br></pre></td></tr></table></figure><p><img src="/blog/2020/02/18/Mysql基础函数及行转列/mysql.png" alt=""></p><h3 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">create table group_by(</span><br><span class="line">name VARCHAR(50),</span><br><span class="line">class VARCHAR(50),</span><br><span class="line">item VARCHAR(50),</span><br><span class="line">price int(10)</span><br><span class="line">)</span><br><span class="line">insert into GROUP_BY VALUES (&apos;张三&apos;,&apos;一班&apos;,&apos;3&apos;,20);</span><br><span class="line">insert into GROUP_BY VALUES (&apos;张三&apos;,&apos;二班&apos;,&apos;5&apos;,70);</span><br><span class="line">insert into GROUP_BY VALUES (&apos;张三&apos;,&apos;三班&apos;,&apos;6&apos;,54);</span><br><span class="line">insert into GROUP_BY VALUES (&apos;李四&apos;,&apos;一班&apos;,&apos;9&apos;,80);</span><br><span class="line">insert into GROUP_BY VALUES (&apos;李四&apos;,&apos;二班&apos;,&apos;2&apos;,50);</span><br><span class="line"># mysql分组小计和合计</span><br><span class="line">SELECT</span><br><span class="line">case when c.name is null then &apos;合计&apos; </span><br><span class="line">else c.name end as name,</span><br><span class="line">case when c.name is null then &apos;&apos;</span><br><span class="line">  when c.class is null then &apos;小计&apos;</span><br><span class="line">else c.class end as class,</span><br><span class="line">c.item as item,</span><br><span class="line">sum(c.price) as price</span><br><span class="line">FROM</span><br><span class="line">GROUP_BY c</span><br><span class="line">GROUP BY</span><br><span class="line">c.NAME,</span><br><span class="line">c.class WITH ROLLUP</span><br></pre></td></tr></table></figure><p><img src="/blog/2020/02/18/Mysql基础函数及行转列/mysql1.png" alt="基础数据"><br><img src="/blog/2020/02/18/Mysql基础函数及行转列/mysql2.jpg" alt="行专列实现分组小计合计"></p><h3 id="IFNULL出现乱码"><a href="#IFNULL出现乱码" class="headerlink" title="IFNULL出现乱码"></a>IFNULL出现乱码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFNULL( cast(t2.maleTotal as CHAR), &apos;&apos; )</span><br></pre></td></tr></table></figure><h3 id="sum-case-when返回0-0"><a href="#sum-case-when返回0-0" class="headerlink" title="sum case when返回0.0"></a>sum case when返回0.0</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUM( CASE `register_sex` WHEN &apos;1&apos; THEN &quot;1&quot; ELSE &apos;0&apos; END ) #后边的1和0不加符号</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MYSQL借用&lt;b&gt;mysql.help_topic&lt;/b&gt;生成连续的日期。&lt;br&gt;&lt;b&gt;mysql.help_topic&lt;/b&gt;是一个从0开始到506的一个序列组（列转行、生成连续日期等）。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://lastsummer.top/blog/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://lastsummer.top/blog/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>使用Dockerfile构建及推送镜像</title>
    <link href="https://lastsummer.top/blog/2020/02/16/%E4%BD%BF%E7%94%A8Dockerfile%E6%9E%84%E5%BB%BA%E5%8F%8A%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F/"/>
    <id>https://lastsummer.top/blog/2020/02/16/使用Dockerfile构建及推送镜像/</id>
    <published>2020-02-16T04:25:13.000Z</published>
    <updated>2020-02-16T06:09:11.219Z</updated>
    
    <content type="html"><![CDATA[<p>Dockerfile是一个文本文件，包含若干条指令，描述了构建镜像的细节。<br>1、<b>Dockerfile</b>修改<b>Nginx</b>镜像的首页。<br>2、<b>Docker部署jar包运行</b>。<a id="more"></a></p><h3 id="Dockerfile修改Nginx镜像的首页"><a href="#Dockerfile修改Nginx镜像的首页" class="headerlink" title="Dockerfile修改Nginx镜像的首页"></a>Dockerfile修改Nginx镜像的首页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@root ~]# mkdir docker</span><br><span class="line">[root@root ~]# cd docker</span><br><span class="line">[root@root ~]# vi Dockerfile# D开头必须大写</span><br><span class="line">FROM nginx</span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello Docker&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br><span class="line">[root@root ~]# docker build -t nginx:wr .# mynginx表示标签 . 表示当前目录</span><br><span class="line">#上行代码如有报错 手打一次即可（编码、空格等问题）</span><br><span class="line">[root@root ~]# docker run -d -p 8888:80 nginx:wr #启动创建的镜像</span><br></pre></td></tr></table></figure><p><img src="/blog/2020/02/16/使用Dockerfile构建及推送镜像/docker.png" alt=""></p><h3 id="Docker部署Jar包运行"><a href="#Docker部署Jar包运行" class="headerlink" title="Docker部署Jar包运行"></a>Docker部署Jar包运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@root ~]# mkdir eureka</span><br><span class="line">[root@root ~]# cd eureka</span><br><span class="line">[root@root ~]# vi Dockerfile# D开头必须大写</span><br><span class="line"></span><br><span class="line"># 基于java镜像</span><br><span class="line">FROM java:8</span><br><span class="line"></span><br><span class="line"># 作者</span><br><span class="line">MAINTAINER wr</span><br><span class="line"></span><br><span class="line"># 复制文件到容器</span><br><span class="line">ADD eureka.jar eureka.jar</span><br><span class="line"></span><br><span class="line"># 声明需要暴露的端口</span><br><span class="line">EXPOSE 8761</span><br><span class="line"></span><br><span class="line"># 配置容器启动后执行的命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;eureka.jar&quot;]</span><br><span class="line"></span><br><span class="line">[root@root ~]# docker build -t wr/eureka:wr . </span><br><span class="line"># -t 指定镜像的仓库名称/镜像名称：标签名称</span><br><span class="line"></span><br><span class="line">[root@root ~]# docker run -d -p 8761:8761 wr/eureka:wr </span><br><span class="line"># -d 后台启动容器，打印容器ID -p 映射端口</span><br></pre></td></tr></table></figure><p><img src="/blog/2020/02/16/使用Dockerfile构建及推送镜像/docker1.png" alt=""></p><h3 id="推送-Docker镜像到Docker-Hub官网"><a href="#推送-Docker镜像到Docker-Hub官网" class="headerlink" title="推送 Docker镜像到Docker Hub官网"></a>推送 Docker镜像到Docker Hub官网</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在[Docker官网](https://lastsummer.top)注册、登录并创建存储库 wangrui</span><br><span class="line">登录docker账号</span><br><span class="line">[root@root ~]# docker login</span><br><span class="line">Username: wangrui</span><br><span class="line">Password:</span><br><span class="line">Login Succeeded</span><br><span class="line">[root@root ~]# docker images</span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                      wr                  9f21117959fe        About an hour ago   127 MB</span><br><span class="line"># tag 打标签 wangrui 为你的 docker hub名字</span><br><span class="line">[root@root ~]# docker tag 9f21117959fe wangrui/nginx:wr</span><br><span class="line">[root@root ~]# docker push wangrui/nginx:wr</span><br></pre></td></tr></table></figure><h3 id="推送-Docker-镜像到-阿里云-官网"><a href="#推送-Docker-镜像到-阿里云-官网" class="headerlink" title="推送 Docker 镜像到 阿里云 官网"></a>推送 Docker 镜像到 阿里云 官网</h3><p>1、<a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">注册阿里云账户</a><br>2、登陆账户<br>3、<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">配置Docker加速器</a><br>4、<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/namespaces" target="_blank" rel="noopener">创建镜像仓库的命名空间</a><br>5、<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/repositories" target="_blank" rel="noopener">创建镜像仓库</a><br>6、操作指南(登录及推送镜像)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker login --username=wangrui registry-internal.cn-hangzhou.aliyuncs.com</span><br><span class="line">$ sudo docker tag [imagesId] registry-internal.cn-hangzhou.aliyuncs.com/wangrui/nginx:wr</span><br><span class="line">$ sudo docker push registry-internal.cn-hangzhou.aliyuncs.com/wangrui/nginx:wr</span><br></pre></td></tr></table></figure></p><p>参考博客：<a href="https://blog.csdn.net/qq_16605855/article/details/79961933" target="_blank" rel="noopener">Docker镜像上传到阿里云的步骤详解</a><br>参考博客：<a href="https://blog.csdn.net/weixin_42054155/article/details/90815393" target="_blank" rel="noopener">Docker部署jar包运行</a><br>参考博客：<a href="https://yangfannie.com/1272.html" target="_blank" rel="noopener">推送你的镜像到Docker Hub</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dockerfile是一个文本文件，包含若干条指令，描述了构建镜像的细节。&lt;br&gt;1、&lt;b&gt;Dockerfile&lt;/b&gt;修改&lt;b&gt;Nginx&lt;/b&gt;镜像的首页。&lt;br&gt;2、&lt;b&gt;Docker部署jar包运行&lt;/b&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://lastsummer.top/blog/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://lastsummer.top/blog/tags/Docker/"/>
    
      <category term="Nginx" scheme="https://lastsummer.top/blog/tags/Nginx/"/>
    
      <category term="Linux" scheme="https://lastsummer.top/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="https://lastsummer.top/blog/2020/02/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>https://lastsummer.top/blog/2020/02/05/分布式事务/</id>
    <published>2020-02-05T13:10:38.000Z</published>
    <updated>2020-02-05T13:47:59.103Z</updated>
    
    <content type="html"><![CDATA[<p>分布式有很多种实现方式，本文讲解可靠消息模式，通过消息队列实现。<a id="more"></a></p><h3 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h3><p>一个大的操作由两个或者更多的小的系统操作共同完成。而这些小的操作又分布在不同的网络主机上。这些操作，要么全部成功执行，要么全部不执行。<br>本质上就是说：分布式事务就是为了保证不同系统、不同数据库的数据一致性。</p><h3 id="消息队列实现分布式事务"><a href="#消息队列实现分布式事务" class="headerlink" title="消息队列实现分布式事务"></a>消息队列实现分布式事务</h3><p>1、把消息写入数据库的消息表（消息表：内容、状态等）<br>2、后台运行定时任务、每次执行从消息表中获取未发送的消息发送到队列，确认返回后修改已发送状态<br>3、重复消息幂等性（创建判重表，判断是否已处理过）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、上游系统保证消息不丢 通过本地消息和后台定时任务程序实现<br>2、下游系统保证消息不重复处理，保证幂等性</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>分布式失误的提交或回滚只取决于事务发起方，也就是无需回滚</p><p><img src="/blog/2020/02/05/分布式事务/分布式事务.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式有很多种实现方式，本文讲解可靠消息模式，通过消息队列实现。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式事务" scheme="https://lastsummer.top/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="队列" scheme="https://lastsummer.top/blog/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="https://lastsummer.top/blog/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客部署Nginx</title>
    <link href="https://lastsummer.top/blog/2020/02/04/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2Nginx/"/>
    <id>https://lastsummer.top/blog/2020/02/04/Hexo博客部署Nginx/</id>
    <published>2020-02-04T12:00:05.000Z</published>
    <updated>2020-02-04T12:37:46.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hexo部署方法"><a href="#Hexo部署方法" class="headerlink" title="Hexo部署方法"></a>Hexo部署方法</h3><p>部署hexo静态博客到生产环境通常有两种方法<br>1、nohup命令执行hexo s由于hexo s，是框架提供的调试方法，不是部署方式，因此在生产环境会存在性能问题不建议使用<br>2、nginx部署静态资源将本地调试好的hexo打包生成的public目录部署到nginx上。nginx性能好访问速度快<a id="more"></a></p><h3 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h3><h4 id="部署在根目录无需处理"><a href="#部署在根目录无需处理" class="headerlink" title="部署在根目录无需处理"></a>部署在根目录无需处理</h4><p>打包：通常在调试环境无需打包，修改后使用hexo s，即可生效，可以直接在本地查看效果。但是，以静态资源的方式部署需要打包生成静态资源，命令为：hexo generate到public文件夹中。</p><h4 id="处理二级目录"><a href="#处理二级目录" class="headerlink" title="处理二级目录"></a>处理二级目录</h4><p>当生产环境中，静态博客部署在二级目录下（如：“http://域名(ip)/blog”这种情况），需要修改hexo工程下的_config.yml配置文件，否则打包生成的css、js文件目录会缺失（默认在根目录），导致无法加载样式。<br>一般修改root和url,增加二级目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: http://lastsummer.top/blog</span><br><span class="line">root: /blog</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></p><h3 id="nginx配置-HTTPS（阿里云申请SSL证书配置即可）"><a href="#nginx配置-HTTPS（阿里云申请SSL证书配置即可）" class="headerlink" title="nginx配置+HTTPS（阿里云申请SSL证书配置即可）"></a>nginx配置+HTTPS（阿里云申请SSL证书配置即可）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1、部署在根目录无需处理，放到nginx webapp中即可</span><br><span class="line">2、部署到二级目录则在webapp中新建二级目录名称，把静态文件放入到二级目录下</span><br><span class="line"> server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.lastsummer.top;</span><br><span class="line">rewrite ^(.*)$ https://$host$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443; </span><br><span class="line">    server_name lastsummer.top;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate  lastsummer.top.pem;</span><br><span class="line">    ssl_certificate_key lastsummer.top.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">root /usr/local/nginx/;</span><br><span class="line">index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">location ^~ /blog &#123;</span><br><span class="line">root /usr/local/nginx;</span><br><span class="line">&#125;</span><br><span class="line">#...缓存等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐博客：<a href="https://www.jianshu.com/p/62acf17b1710" target="_blank" rel="noopener">nginx部署hexo的方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hexo部署方法&quot;&gt;&lt;a href=&quot;#Hexo部署方法&quot; class=&quot;headerlink&quot; title=&quot;Hexo部署方法&quot;&gt;&lt;/a&gt;Hexo部署方法&lt;/h3&gt;&lt;p&gt;部署hexo静态博客到生产环境通常有两种方法&lt;br&gt;1、nohup命令执行hexo s由于hexo s，是框架提供的调试方法，不是部署方式，因此在生产环境会存在性能问题不建议使用&lt;br&gt;2、nginx部署静态资源将本地调试好的hexo打包生成的public目录部署到nginx上。nginx性能好访问速度快&lt;/p&gt;
    
    </summary>
    
      <category term="HEXO" scheme="https://lastsummer.top/blog/categories/HEXO/"/>
    
    
      <category term="Git" scheme="https://lastsummer.top/blog/tags/Git/"/>
    
      <category term="Nginx" scheme="https://lastsummer.top/blog/tags/Nginx/"/>
    
      <category term="Linux" scheme="https://lastsummer.top/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装和使用</title>
    <link href="https://lastsummer.top/blog/2020/02/03/Docker%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://lastsummer.top/blog/2020/02/03/Docker安装和使用/</id>
    <published>2020-02-03T08:34:36.000Z</published>
    <updated>2020-02-04T12:38:01.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Docker时dotCloud公司开源的一个基于LXC技术之上搭建的Container容器引擎，源代码托管在Github上，基于Go语言并遵从Apache2.0协议开源。<br>Docker属于Linux容器的一种封装，提供简单易用的容器使用接口。<br>Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker，就不用担心环境问题。<br>总体来说，Docker的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。<br><b>同时 Docker 划分为 CE 和 EE。CE 即社区版（免费，支持周期三个月），EE 即企业版，强调安全，付费使用。<b><a id="more"></a></b></b></p><h3 id="CentOS安装Docker-CE"><a href="#CentOS安装Docker-CE" class="headerlink" title="CentOS安装Docker CE"></a>CentOS安装Docker CE</h3><h4 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h4><p>目前，CentOS 仅发行版本中的内核支持 Docker。<br>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</p><h4 id="使用-yum-安装（CentOS-7）"><a href="#使用-yum-安装（CentOS-7）" class="headerlink" title="使用 yum 安装（CentOS 7）"></a>使用 yum 安装（CentOS 7）</h4><p>通过 uname -r 命令查看你当前的内核版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@1234qwer ~]# uname -r </span><br><span class="line">3.10.0-957.21.2.el7.x86_64</span><br></pre></td></tr></table></figure></p><h4 id="更新系统-可选"><a href="#更新系统-可选" class="headerlink" title="更新系统(可选)"></a>更新系统(可选)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h4 id="安装-Dockedr-CE"><a href="#安装-Dockedr-CE" class="headerlink" title="安装 Dockedr CE"></a>安装 Dockedr CE</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br><span class="line"># Docker 版本</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h4 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><h3 id="Docker-命令"><a href="#Docker-命令" class="headerlink" title="Docker 命令"></a>Docker 命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 从Docker Hub下载tomcat最新版镜像</span><br><span class="line">docker pull tomcat</span><br><span class="line"># 启动tomcat容器</span><br><span class="line">docker run -d -p 8080:16000 tomcat</span><br><span class="line"># 列出所有在运行的容器信息。</span><br><span class="line">docker ps </span><br><span class="line"># Docker 运行容器ID控制台：</span><br><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line"># 两种退出容器的方式</span><br><span class="line">docker kill 容器ID</span><br><span class="line">docker stop 容器ID</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Docker时dotCloud公司开源的一个基于LXC技术之上搭建的Container容器引擎，源代码托管在Github上，基于Go语言并遵从Apache2.0协议开源。&lt;br&gt;Docker属于Linux容器的一种封装，提供简单易用的容器使用接口。&lt;br&gt;Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker，就不用担心环境问题。&lt;br&gt;总体来说，Docker的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。&lt;br&gt;&lt;b&gt;同时 Docker 划分为 CE 和 EE。CE 即社区版（免费，支持周期三个月），EE 即企业版，强调安全，付费使用。&lt;b&gt;&lt;/b&gt;&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://lastsummer.top/blog/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://lastsummer.top/blog/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>JWT生成TOKEN</title>
    <link href="https://lastsummer.top/blog/2020/01/25/JWT%E7%94%9F%E6%88%90TOKEN/"/>
    <id>https://lastsummer.top/blog/2020/01/25/JWT生成TOKEN/</id>
    <published>2020-01-25T03:26:15.000Z</published>
    <updated>2020-02-03T09:04:37.336Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Jwt 是一种生成token,或者解析token 返回对象的工具，现在流行的都是前后端分离项目，用之前的shiro,或者sercurity 去做权限是会遇到无法做前端的权限，所以就采用token 这种方式，服务器返回token  给前端，前端通过token 访问资源，前端通过cookie保存。<br><a id="more"></a></p><h3 id="什么是jwt"><a href="#什么是jwt" class="headerlink" title="什么是jwt"></a>什么是jwt</h3><p>WT本质上是一个字符串，一个完整的JWT由三部分组成，头部(header), 荷载(Payload), 和签名(Signature)，中间用.隔开，如下是一个典型的JWT：eyJhbGciOiJIUzUxMiJ9.iIxMjM0NSIsInN1YiI6InhsIn0.5MSq92FV7vneEo9IrrZw9XH6g<br><b>注意：保存的信息越多，生成的token长度越长<b></b></b></p><h3 id="JWT-头部（Header）"><a href="#JWT-头部（Header）" class="headerlink" title="JWT 头部（Header）"></a>JWT 头部（Header）</h3><p>用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。<br>{“typ”:”JWT”,”alg”:”HS256”}</p><h3 id="载荷（playload）"><a href="#载荷（playload）" class="headerlink" title="载荷（playload）"></a>载荷（playload）</h3><p>载荷就是存放有效信息的地方（自定义变量+标准变量）。</p><h3 id="签证（signature）"><a href="#签证（signature）" class="headerlink" title="签证（signature）"></a>签证（signature）</h3><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：<br>这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。<br>eyJhbGciOiJIUzUxMiJ9.iIxMjM0NSIsInN1YiI6InhsIn0.5MSq92FV7vneEo9IrrZw9XH6g</p><h3 id="引入依赖包"><a href="#引入依赖包" class="headerlink" title="引入依赖包"></a>引入依赖包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.6.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">``` </span><br><span class="line">### JWT工具类</span><br></pre></td></tr></table></figure><p>package com.zes.utils;</p><p>import com.zexx.springcloudcommon.exception.WebException;<br>import com.zexx.springcloudcommon.utils.StringUtil;<br>import io.jsonwebtoken.Claims;<br>import io.jsonwebtoken.Jwts;<br>import io.jsonwebtoken.SignatureAlgorithm;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.beans.factory.annotation.Value;<br>import org.springframework.data.redis.core.RedisTemplate;<br>import org.springframework.stereotype.Component;</p><p>import java.io.Serializable;<br>import java.util.Date;<br>import java.util.HashMap;<br>import java.util.Map;<br>import java.util.concurrent.TimeUnit;</p><p>/**</p><ul><li>Description: JWT生成token相关的工具类<br>*</li><li>@author wangrui</li><li><p>@date 2019/12/18<br>*/<br>@Component<br>public class JwtTokenUtil implements Serializable {</p><p> private static final long serialVersionUID = -4324967L;</p><p> //用户名称<br> private static final String CLAIM_KEY_USERNAME = “CLAIM_KEY_USERNAME”;<br> //创建时间<br> private static final String CLAIM_KEY_CREATE_TIME = “CLAIM_KEY_CREATE_TIME”;<br> //结束时间<br> private static final String CLAIM_KEY_END_TIME = “CLAIM_KEY_END_TIME”;</p><p> //注入redis<br> @Autowired<br> private RedisTemplate redisTemplate;</p><p> // JWT 密钥（服务器密钥加密解密 application.yml配置）<br> @Value(“${jwt.secret}”)<br> private String secret;</p><p> // redis存储时间 分钟 一般24小时<br> @Value(“${jwt.redisexpiration}”)<br> private Long redisExpiration;</p><p> //签发人<br> @Value(“${jwt.issuer}”)<br> private String issuer;</p><p> /**</p><ul><li>Description: 解析token，从token中获取信息<br>*</li><li><p>@param token<br>*/<br>private Claims getClaimsFromToken(String token) {<br> Claims claims;<br> try {</p><pre><code>claims = Jwts.parser()        .setSigningKey(secret)        .parseClaimsJws(token)        .getBody();</code></pre><p> } catch (Exception e) {</p><pre><code>e.printStackTrace();claims = null;</code></pre><p> }<br> return claims;<br>}</p><p>/**</p></li><li>Description:获取用户名<br>*</li><li><p>@param token<br>*/<br>public String getUserNameFromToken(String token) {<br> String userName;<br> try {</p><pre><code>final Claims claims = getClaimsFromToken(token);userName = claims.get(CLAIM_KEY_USERNAME) == null ? &quot;&quot; : claims.get(CLAIM_KEY_USERNAME).toString();</code></pre><p> } catch (Exception e) {</p><pre><code>userName = null;</code></pre><p> }<br> return userName;<br>}</p><p>/**</p></li><li>Description:获取token创建时间<br>*</li><li><p>@param token<br>*/<br>public Date getCreatedDateFromToken(String token) {<br> Date created;<br> try {</p><pre><code>final Claims claims = getClaimsFromToken(token);created = new Date((Long) claims.get(CLAIM_KEY_CREATE_TIME));</code></pre><p> } catch (Exception e) {</p><pre><code>created = null;</code></pre><p> }<br> return created;<br>}</p><p>/**</p></li><li>Description: 获取token过期时间<br>*</li><li><p>@param token<br>*/<br>public Date getExpirationDateFromToken(String token) {<br> Date expiration;<br> try {</p><pre><code>final Claims claims = getClaimsFromToken(token);expiration = claims.getExpiration();</code></pre><p> } catch (Exception e) {</p><pre><code>expiration = null;</code></pre><p> }<br> return expiration;<br>}</p><p>/**</p></li><li><p>Description:token生成过期时间<br><em>/<br>private Date generateExpirationDate() {<br> return new Date(System.currentTimeMillis() + redisExpiration </em> 60 * 1000);<br>}</p><p>/**</p></li><li>Description:token是否过期<br>*</li><li><p>@param token<br>*/<br>private Boolean isTokenExpired(String token) {<br> final Date expiration = getExpirationDateFromToken(token);<br> return expiration.before(new Date());<br>}</p><p>/**</p></li><li><p>Description: 创建token<br>*/<br>public String generateToken(String userName, String mac) {<br> Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();<br> claims.put(CLAIM_KEY_USERNAME, userName);<br> claims.put(CLAIM_KEY_CREATE_TIME, new Date());<br> claims.put(CLAIM_KEY_END_TIME, generateExpirationDate());<br> return generateToken(claims);<br>}</p><p>/**</p></li><li><p>Description:使用Rs256签名<br>*/<br>private String generateToken(Map&lt;String, Object&gt; claims) {<br> return Jwts.builder()</p><pre><code>.setClaims(claims)//自定义变量.setIssuer(issuer).setIssuedAt(new Date())//发行时间.setAudience((String) claims.get(CLAIM_KEY_USERNAME)).setExpiration(generateExpirationDate())//过期时间.signWith(SignatureAlgorithm.HS512, secret)//签名密钥.compact();</code></pre><p>}</p><p>/**</p></li><li>Description:验证token<br>*</li><li>@param token</li><li>@param userName</li><li>@param mac<br>*/<br>public boolean validateToken(String token, String userName, String mac) {<br> String tokenName = “”;<br> try {<pre><code>if (redisTemplate.hasKey(&quot;token_&quot; + userName)) {    tokenName = (String) redisTemplate.opsForValue().get(&quot;token_&quot; + userName);    if (tokenName.equals(token)) {        return true;    } else {        //自定义异常        throw new WebException(&quot;无效令牌&quot;);    }}</code></pre> } catch (WebException e) {<pre><code>throw new WebException(e.getMessage());</code></pre> }<br> return false;<br>}<br>}<br><code>`</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Jwt 是一种生成token,或者解析token 返回对象的工具，现在流行的都是前后端分离项目，用之前的shiro,或者sercurity 去做权限是会遇到无法做前端的权限，所以就采用token 这种方式，服务器返回token  给前端，前端通过token 访问资源，前端通过cookie保存。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://lastsummer.top/blog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>微服务下实现日志模块</title>
    <link href="https://lastsummer.top/blog/2019/12/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8B%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/"/>
    <id>https://lastsummer.top/blog/2019/12/09/微服务下实现日志模块/</id>
    <published>2019-12-09T08:39:48.000Z</published>
    <updated>2019-12-09T09:32:46.586Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微服务下实现日志模块"><a href="#微服务下实现日志模块" class="headerlink" title="微服务下实现日志模块"></a>微服务下实现日志模块</h3><p>与传统单体应用不同，微服务下由于，项目模块、业务拆分成多个独立系统，数据库一般也相互独立。<br>所以对于日志的统一管理和收集，也趋于复杂，借助于springboot自动配置和spring事件发布订阅（RabbitMq）、SpringAop以及组件化思想，构建一个通用日志模块<br><a id="more"></a></p><h4 id="自定义SysLog注解"><a href="#自定义SysLog注解" class="headerlink" title="自定义SysLog注解"></a>自定义SysLog注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义日志注解</span><br><span class="line"> * @author wangrui</span><br><span class="line"> * @date 2019-12-9</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SysLog &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 服务(子系统)名 默认取$&#123;spring.application.name&#125;</span><br><span class="line">     */</span><br><span class="line">    String serverName() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 日志描述信息</span><br><span class="line">     */</span><br><span class="line">    String description() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过Aop-pointCut拦截-SysLog的请求"><a href="#通过Aop-pointCut拦截-SysLog的请求" class="headerlink" title="通过Aop pointCut拦截@SysLog的请求"></a>通过Aop pointCut拦截@SysLog的请求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * aop拦截</span><br><span class="line"> * @author wangrui</span><br><span class="line"> * @date 2019-06-09 17:47</span><br><span class="line"> */</span><br><span class="line">@Aspect</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">    private ThreadPoolTaskExecutor taskExecutor;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">    private AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.application.name&#125;&quot;)</span><br><span class="line">    private String serverName;</span><br><span class="line"></span><br><span class="line">    @Around(value = &quot;@annotation(SysLog)&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point, ZgLog zgLog) throws Throwable &#123;</span><br><span class="line">        String strClassName = point.getTarget().getClass().getName();</span><br><span class="line">        String strMethodName = point.getSignature().getName();</span><br><span class="line">        SysLog logVo = SysLogUtils.getSysLog();</span><br><span class="line">        logVo.setServerName(StringUtils.isNotBlank(zgLog.serverName()) ? zgLog.serverName() : serverName);</span><br><span class="line">        logVo.setModule(zgLog.module());</span><br><span class="line">        logVo.setDescription(zgLog.description());</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        Object obj = point.proceed();</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        logVo.setTime(endTime - startTime);</span><br><span class="line">        1、实现spirng消息发布及订阅</span><br><span class="line">        2、springboot连接池异步多线程发送消息</span><br><span class="line">        taskExecutor.execute(new MyThread());</span><br><span class="line">        3、mq异步发送保存日志信息</span><br><span class="line">        amqpTemplate.convertAndSend(&quot;springcloud.exchange&quot;,&quot;log&quot;, JSONObject.toJSONString(logVo));</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;微服务下实现日志模块&quot;&gt;&lt;a href=&quot;#微服务下实现日志模块&quot; class=&quot;headerlink&quot; title=&quot;微服务下实现日志模块&quot;&gt;&lt;/a&gt;微服务下实现日志模块&lt;/h3&gt;&lt;p&gt;与传统单体应用不同，微服务下由于，项目模块、业务拆分成多个独立系统，数据库一般也相互独立。&lt;br&gt;所以对于日志的统一管理和收集，也趋于复杂，借助于springboot自动配置和spring事件发布订阅（RabbitMq）、SpringAop以及组件化思想，构建一个通用日志模块&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="https://lastsummer.top/blog/categories/SpringCloud/"/>
    
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/tags/JAVA/"/>
    
      <category term="SpringBoot" scheme="https://lastsummer.top/blog/tags/SpringBoot/"/>
    
      <category term="SpringCloud" scheme="https://lastsummer.top/blog/tags/SpringCloud/"/>
    
      <category term="RabbitMQ" scheme="https://lastsummer.top/blog/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud基础</title>
    <link href="https://lastsummer.top/blog/2019/11/26/SpringCloud%E5%9F%BA%E7%A1%80/"/>
    <id>https://lastsummer.top/blog/2019/11/26/SpringCloud基础/</id>
    <published>2019-11-26T11:55:15.000Z</published>
    <updated>2019-11-27T08:58:11.959Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SpringCloud基础"><a href="#SpringCloud基础" class="headerlink" title="SpringCloud基础"></a>SpringCloud基础</h3><a id="more"></a><h4 id="微服务的优缺点"><a href="#微服务的优缺点" class="headerlink" title="微服务的优缺点"></a>微服务的优缺点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">微服务是一种架构模式，叫微服务架构更合理，把一个系统的各个功能点都拆开为一个个的应用单独部署</span><br><span class="line">优点：</span><br><span class="line">1.每个服务直接足够内聚，代码容易理解</span><br><span class="line">2.开发效率高，一个服务只做一件事，适合小团队开发</span><br><span class="line">3.松耦合，有功能意义的服务</span><br><span class="line">4.可以用不同语言开发，面向接口编程</span><br><span class="line">5.易于第三方集成</span><br><span class="line">6.微服务只是业务逻辑的代码，不会和HTML,CSS或其他界面结合</span><br><span class="line">7.可以灵活搭配，连接公共库/连接独立库</span><br><span class="line">缺点：</span><br><span class="line">1.分布式系统的责任性</span><br><span class="line">2.多服务运维难度加大</span><br><span class="line">3.系统部署依赖，服务间通信成本，数据一致性，系统集成测试，性能监控</span><br></pre></td></tr></table></figure><h4 id="springCloud"><a href="#springCloud" class="headerlink" title="springCloud?"></a>springCloud?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring cloud流应用程序启动器是基于Spring Boot的Spring集成应用程序，提供与外部系统的集成</span><br><span class="line">Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序</span><br><span class="line">相比Dubbo等RPC框架,Spring Cloud提供的全套的分布式系统解决方案</span><br></pre></td></tr></table></figure><h4 id="springCloud和Dubbo区别"><a href="#springCloud和Dubbo区别" class="headerlink" title="springCloud和Dubbo区别?"></a>springCloud和Dubbo区别?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.服务调用方式 dubbo基于RPC springcloud基于Rest Api</span><br><span class="line">2.注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper</span><br><span class="line">3.服务网关,dubbo本身没有实现，只能通过其他第三方技术整合</span><br><span class="line">springcloud有Zuul路由网关，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素</span><br></pre></td></tr></table></figure><h4 id="RPC和REST区别？"><a href="#RPC和REST区别？" class="headerlink" title="RPC和REST区别？"></a>RPC和REST区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REST是一种架构风格，REST规范把所有内容都视为资源，网络上一切皆资源</span><br><span class="line">REST并没有创造新的技术，组件或服务，只是使用Web的现有特征和能力</span><br><span class="line">完全通过HTTP协议实现，使用 HTTP 协议处理数据通信</span><br><span class="line">REST架构对资源的操作CRTUD的操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法</span><br><span class="line">RPC远程方法调用，就是像调用本地方法一样调用远程方法</span><br></pre></td></tr></table></figure><p><img src="/blog/2019/11/26/SpringCloud基础/RPC与REST.png" alt="RPC和REST区别"></p><h4 id="微服务通信方式？"><a href="#微服务通信方式？" class="headerlink" title="微服务通信方式？"></a>微服务通信方式？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.RestTemplate</span><br><span class="line">（1）restTemplate.getForObject(&quot;http://localhost:8773/hi&quot;,String.class);</span><br><span class="line">（2）loadBalancerClient</span><br><span class="line">（3）server_id服务调用</span><br><span class="line">2.远程调用，比如feign接口调用，直接通过远程过程调用来访问别的service。</span><br><span class="line">3.消息中间件rabbitmq</span><br></pre></td></tr></table></figure><h4 id="Eureka和Zookeeper区别"><a href="#Eureka和Zookeeper区别" class="headerlink" title="Eureka和Zookeeper区别?"></a>Eureka和Zookeeper区别?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Eureka取CAP的AP，注重可用性，Zookeeper取CAP的CP注重一致性</span><br><span class="line">2.Zookeeper在选举期间注册服务瘫痪，虽然服务最终会恢复，但选举期间不可用</span><br><span class="line">3.eureka的自我保护机制，会导致一个结果就是不会再从注册列表移除因长时间没收到心跳而过期的服务。依然能接受新服务的注册和查询请求，但不会被同步到其他节点。不会服务瘫痪</span><br><span class="line">4.Zookeeper有Leader和Follower角色，Eureka各个节点平等</span><br><span class="line">5.Zookeeper采用过半数存活原则，Eureka采用自我保护机制解决分区问题</span><br><span class="line">6.eureka本质是一个工程，Zookeeper只是一个进程</span><br></pre></td></tr></table></figure><h4 id="Eureka和Zookeeper中CAP区别？"><a href="#Eureka和Zookeeper中CAP区别？" class="headerlink" title="Eureka和Zookeeper中CAP区别？"></a>Eureka和Zookeeper中CAP区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CAP理论</span><br><span class="line">1.C（Consistency）：数据一致性</span><br><span class="line">2.A（Availability）：可用性</span><br><span class="line">3.P（Partition Tolerance）：分区容错性</span><br><span class="line">当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，单不能接受服务直接down掉不可用,服务注册功能对可用性的要求要高于一致性</span><br><span class="line">Eureka看明白了这点，因此在设计师就有限保证可用性，Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时如果发现连接失败，会自动切换至其他节点，只要有一台Eureka还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证强一致性）,Eureka还有一种自我保护机制</span><br><span class="line">Eureka基于AP原则，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像Zookeeper 那样使整个注册服务瘫痪</span><br><span class="line">Zookeeper基于CP原则，不是强一致的，并且选举时间在30-120秒在选举期间集群不可用，服务瘫痪</span><br><span class="line">作为注册中心，最主要得到就是保证可用性，可以接受短时间内数据不一致的情况</span><br><span class="line">个人觉得Eureka做i为单纯的服务注册中心来说比Zookeeper更专业一点</span><br></pre></td></tr></table></figure><h4 id="Eureka的自我保护机制？"><a href="#Eureka的自我保护机制？" class="headerlink" title="Eureka的自我保护机制？"></a>Eureka的自我保护机制？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障</span><br><span class="line">当Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，保护注册信息，不再删除注册数据，故障恢复时，自动退出自我保护模式。</span><br><span class="line">1、Eureka不再从注册列表中溢出因为长时间没有收到心跳而应该过期的服务</span><br><span class="line">2、Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点依然可用）</span><br><span class="line">3、当网络稳定是，当前实例新的注册信息会被同步到其他节点中</span><br><span class="line">因此，Eureka可以很好的应对网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪</span><br></pre></td></tr></table></figure><h4 id="Ribbon和Feign的区别？"><a href="#Ribbon和Feign的区别？" class="headerlink" title="Ribbon和Feign的区别？"></a>Ribbon和Feign的区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Ribbon都是调用其他服务的，但方式不同</span><br><span class="line">2.启动类注解不同，Ribbon是@RibbonClient feign的是@EnableFeignClients</span><br><span class="line">3.服务指定的位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明</span><br><span class="line">4.调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用的方法定义成抽象方法即可</span><br></pre></td></tr></table></figure><h4 id="什么是Spring-Cloud-Bus"><a href="#什么是Spring-Cloud-Bus" class="headerlink" title="什么是Spring Cloud Bus?"></a>什么是Spring Cloud Bus?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring cloud bus </span><br><span class="line">将分布式的节点用轻量的消息代理连接起来，可用于广播配置文件的更改或者服务直接的通讯和监控</span><br><span class="line">如果修改了配置文件，发送一次请求，所有的客户端便会重新读取配置文件</span><br></pre></td></tr></table></figure><h4 id="springcloud断路器作用"><a href="#springcloud断路器作用" class="headerlink" title="springcloud断路器作用?"></a>springcloud断路器作用?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）</span><br><span class="line">打开:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务</span><br><span class="line">半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭</span><br><span class="line">关闭：当服务一直处于正常状态 能正常调用</span><br></pre></td></tr></table></figure><h4 id="什么是SpringCloudConfig"><a href="#什么是SpringCloudConfig" class="headerlink" title="什么是SpringCloudConfig?"></a>什么是SpringCloudConfig?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件</span><br><span class="line">在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中</span><br><span class="line">在spring cloud config 组件中，分两个角色，一是config server，二是config client</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SpringCloud基础&quot;&gt;&lt;a href=&quot;#SpringCloud基础&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud基础&quot;&gt;&lt;/a&gt;SpringCloud基础&lt;/h3&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="https://lastsummer.top/blog/categories/SpringCloud/"/>
    
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/tags/JAVA/"/>
    
      <category term="SpringBoot" scheme="https://lastsummer.top/blog/tags/SpringBoot/"/>
    
      <category term="SpringCloud" scheme="https://lastsummer.top/blog/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令详解</title>
    <link href="https://lastsummer.top/blog/2019/11/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lastsummer.top/blog/2019/11/26/Linux常用命令详解/</id>
    <published>2019-11-26T01:54:23.000Z</published>
    <updated>2019-11-27T06:08:02.243Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux常用命令详解"><a href="#Linux常用命令详解" class="headerlink" title="Linux常用命令详解"></a>Linux常用命令详解</h3><a id="more"></a><h4 id="关机及重启"><a href="#关机及重启" class="headerlink" title="关机及重启"></a>关机及重启</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now 立刻关机</span><br><span class="line">shutdown -h 5 5分钟后关机</span><br><span class="line">poweroff 立刻关机</span><br><span class="line"></span><br><span class="line">shutdown -r now</span><br><span class="line">shutdown -r 5 5分钟后重启</span><br><span class="line">reboot 立刻重启</span><br></pre></td></tr></table></figure><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown --help：</span><br><span class="line">ifconfig  --help：查看网卡信息</span><br></pre></td></tr></table></figure><h4 id="目录操作指令"><a href="#目录操作指令" class="headerlink" title="目录操作指令"></a>目录操作指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cd 切换目录</span><br><span class="line">ls 目录查看</span><br><span class="line">mkdir aaa 创建目录</span><br><span class="line">rm -f aaa 删除当前目录下的aaa目录（不询问）</span><br><span class="line">rm -r aaa 递归删除当前下的aaa目录</span><br><span class="line">rm -rf aaa 递归删除当前目录下的aaa目录（不询问，谨慎使用，避免全部删除）</span><br><span class="line">rm可以删除文件、目录、压缩包、</span><br><span class="line">mv 移动文件或者重命名文件或目录</span><br><span class="line">cp -r 目录名称 目录拷贝的目标位置   -r代表递归</span><br><span class="line">find 目录 参数 文件名称 搜索目录 find /usr/tmp -name &apos;a*&apos; </span><br><span class="line">touch aaa.txt 创建文件</span><br><span class="line">pwd 查看当前目录</span><br><span class="line">vim及vi编辑器命令模式底行模式及插入模式</span><br><span class="line">cat 文件的查看 看最后一屏</span><br><span class="line">more 百分比查看</span><br><span class="line">less 翻页查看</span><br><span class="line">head 显示文件头数据</span><br><span class="line">tail 指定行数或者动态查看</span><br><span class="line">echo 创建带有内容的文件</span><br></pre></td></tr></table></figure><h4 id="安装下载解压操作"><a href="#安装下载解压操作" class="headerlink" title="安装下载解压操作"></a>安装下载解压操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum 应用市场安装</span><br><span class="line">wegt 加地址 表示下载</span><br><span class="line">tar -zvxf</span><br><span class="line">-A 新增文件到已压缩文件中</span><br><span class="line">-c 新建新压缩文件</span><br><span class="line">-r 将新文件添加到已压缩文件的末尾</span><br><span class="line">-x 解压缩文件</span><br><span class="line">-k 保留原压缩文件</span><br><span class="line">-f 待压缩或待解压缩文件</span><br><span class="line">-j bzip2格式</span><br><span class="line">-z gzip格式</span><br><span class="line">-v 显示过程</span><br></pre></td></tr></table></figure><h4 id="权限修改"><a href="#权限修改" class="headerlink" title="权限修改"></a>权限修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chmod</span><br><span class="line">权限分为三种：读（r=4），写（w=2），执行（x=1）</span><br><span class="line">可读可执行 rx=5=4+1</span><br><span class="line">可读可写 rw=6=4+2</span><br><span class="line">可执行可写 wx=3=2+1</span><br><span class="line">可读可写可执行 rwx=7=4+1+2</span><br><span class="line">常用数字权限</span><br><span class="line">-rw------- (600) 只有拥有者有读写权限。</span><br><span class="line">-rw-r--r-- (644) 只有拥有者有读写权限；而属组用户和其他用户只有读权限。</span><br><span class="line">-rwx------ (700) 只有拥有者有读、写、执行权限。</span><br><span class="line">-rwxr-xr-x (755) 拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。</span><br><span class="line">-rwx--x--x (711) 拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。</span><br><span class="line">-rw-rw-rw- (666) 所有用户都有文件读、写权限。</span><br><span class="line">-rwxrwxrwx (777) 所有用户都有读、写、执行权限。</span><br><span class="line">创建sh文件后需要赋予可执行权限</span><br></pre></td></tr></table></figure><h4 id="进程命令"><a href="#进程命令" class="headerlink" title="进程命令"></a>进程命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java 查看进程</span><br><span class="line">su 默认切换root用户</span><br><span class="line">ps -ef 查看所有正在运行的进程</span><br><span class="line">kill pid 杀死进程</span><br><span class="line">kill -9 pid 强制杀死进程</span><br><span class="line">ifconfig 查看你网卡信息</span><br><span class="line">ping 查看与某台机器的连接情况</span><br><span class="line">netstat 显示网络状态信息</span><br><span class="line">netstat -an 查看当前系统接口</span><br><span class="line">netstat -an | grep 8080 搜索指定端口8080</span><br><span class="line">clear 清屏</span><br><span class="line">usermod 修改用户</span><br><span class="line">useradd 添加用户</span><br><span class="line">userdel 删除用户</span><br><span class="line">passwd 修改密码</span><br><span class="line">groupadd 添加用户组</span><br><span class="line">groupmod 修改用户组</span><br><span class="line">groupdel 删除用户组</span><br></pre></td></tr></table></figure><h4 id="环境变量路径配置"><a href="#环境变量路径配置" class="headerlink" title="环境变量路径配置"></a>环境变量路径配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile java环境变量</span><br><span class="line">/etc/sysconfig/network-scripts/ifcfg-eno 网卡配置</span><br><span class="line">source /etc/profile 刷新环境变量</span><br><span class="line">uname -a 查看系统版本</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux常用命令详解&quot;&gt;&lt;a href=&quot;#Linux常用命令详解&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令详解&quot;&gt;&lt;/a&gt;Linux常用命令详解&lt;/h3&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://lastsummer.top/blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://lastsummer.top/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java代理模式</title>
    <link href="https://lastsummer.top/blog/2019/11/14/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lastsummer.top/blog/2019/11/14/Java代理模式/</id>
    <published>2019-11-14T05:50:03.000Z</published>
    <updated>2019-11-22T04:31:53.985Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java代理模式"><a href="#Java代理模式" class="headerlink" title="Java代理模式"></a>Java代理模式</h3><a id="more"></a><p>代理模式主要为其他对象提供一种代理以控制这个对象的访问。在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，好比你将一些繁琐的事情交给第三方去管理，那么第三方就是你的代理，其他人只会去找这个代理，而不会去找你，<b>AOP本身就是基于动态代理实现的</b>，所以掌握了代理模式对AOP的学习很有帮助的哦。<br><b>代理模式的三种种实现方式(静态代理、jdk动态代理、CGLib代理)</b></p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>代理类在程序运行前就已经存在,那么这种代理方式被成为静态代理(接口、实现类、代理类都存在)</p><h4 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h4><p>代理类在程序运行时创建的代理方式被称为 动态代理<br>如果目标对象实现了接口,采用JDK的动态代理(接口、实现类存在，代理类运行后创建)<br>如果目标对象没有实现接口,必须采用cglib动态代理(实现类，代理类运行后创建)</p><h4 id="CGLib代理"><a href="#CGLib代理" class="headerlink" title="CGLib代理"></a>CGLib代理</h4><p>目标类不能为final,目标对象的方法如果为final / static，那么就不会被拦截，即不会执行目标对象额外的业务方法</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>静态代理：<br>(1)可以做到在不修改目标对象的功能前提下,对目标功能扩展<br>(2)代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护<br>JDK动态代理:<br>(1)代理对象不需要实现接口, 利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)<br>(2)目标对象一定要实现接口,否则不能用动态代理<br>CGLib代理:<br>(1)静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象类实现代理</p><p>JDK动态代理使用Java的反射技术生成代理类，只能代理实现了接口的类，没有实现接口的类不能实现动态代理，CGLib会在运行时动态的生成一个被代理类的子类，子类重写了被代理类中所有非final的方法，在子类中采用方法拦截的技术拦截所有父类方法的调用，不需要被代理类对象实现接口，从而CGLIB动态代理效率比Jdk动态代理反射技术效率要高</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java代理模式&quot;&gt;&lt;a href=&quot;#Java代理模式&quot; class=&quot;headerlink&quot; title=&quot;Java代理模式&quot;&gt;&lt;/a&gt;Java代理模式&lt;/h3&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://lastsummer.top/blog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java8中抽象类与接口的异同</title>
    <link href="https://lastsummer.top/blog/2019/11/06/Java8%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%82%E5%90%8C/"/>
    <id>https://lastsummer.top/blog/2019/11/06/Java8中抽象类与接口的异同/</id>
    <published>2019-11-06T10:37:28.000Z</published>
    <updated>2019-11-06T10:47:32.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-8中抽象类与接口的异同"><a href="#Java-8中抽象类与接口的异同" class="headerlink" title="Java 8中抽象类与接口的异同"></a>Java 8中抽象类与接口的异同</h3><a id="more"></a><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)都是抽象类型；</span><br><span class="line">(2)都可以有实现方法（以前接口不行）；</span><br><span class="line">(3)都可以不需要实现类或者继承者去实现所有方法,以前不行，现在接口中默认方法不需要实现者实现</span><br></pre></td></tr></table></figure><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）；</span><br><span class="line">(2)抽象类和接口所反映出的设计理念不同。</span><br><span class="line">  其实抽象类表示的是&quot;is-a&quot;关系，接口表示的是&quot;like-a&quot;关系；</span><br><span class="line">(3)接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值；</span><br><span class="line">  抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。</span><br></pre></td></tr></table></figure><h4 id="接口实例"><a href="#接口实例" class="headerlink" title="接口实例"></a>接口实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public interface InterfaceClass &#123;</span><br><span class="line"></span><br><span class="line">//接口中的常量定义（必须为其赋值）</span><br><span class="line">public static final String s = &quot;1&quot;;</span><br><span class="line"></span><br><span class="line">//抽象方法的定义（没有具体的实现）</span><br><span class="line">public abstract void query();</span><br><span class="line"></span><br><span class="line">//没有构造方法</span><br><span class="line"></span><br><span class="line">//java8新增的默认方法(默认方法实现类可以实现也可以不实现，不实现也能直接调用接口的默认方法)</span><br><span class="line">default void default1() &#123;</span><br><span class="line">System.out.println(&quot;测试默认方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    //默认方法的重载</span><br><span class="line">    default  void default1(String a) &#123;</span><br><span class="line">        System.out.println(&quot;测试默认方法111&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //包含方法的实现的静态方法（实现类不能重写此方法）</span><br><span class="line">static String static1() &#123;</span><br><span class="line">System.out.println(&quot;这是一个静态的方法！！！&quot;);</span><br><span class="line">return &quot;这是一个静态的方法！！！&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">testInterface test = new testInterface();</span><br><span class="line">System.out.println(test.s);</span><br><span class="line">test.default1();</span><br><span class="line">test.default1(&quot;ss&quot;);</span><br><span class="line">System.out.println(InterfaceClass.s);</span><br><span class="line">System.out.print(InterfaceClass.static1());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class testInterface implements InterfaceClass&#123;</span><br><span class="line">@Override</span><br><span class="line">public void query() &#123;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void default1() &#123;</span><br><span class="line">System.out.println(&quot;子类自我实现默认方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void default1(String a) &#123;</span><br><span class="line">InterfaceClass.super.default1(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象实例"><a href="#抽象实例" class="headerlink" title="抽象实例"></a>抽象实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">//构造代码块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static&#123;</span><br><span class="line">//可以有静态代码块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象类中变量的定义，默认为friendly类型，默认类型，只允许包内访问</span><br><span class="line">String s = &quot;1&quot;;</span><br><span class="line"></span><br><span class="line">//可以有构造方法</span><br><span class="line">public AbstractClass() &#123;&#125;</span><br><span class="line"></span><br><span class="line">//抽象方法使用public abstract、protected abstract、abstract修饰</span><br><span class="line">public abstract void query();</span><br><span class="line">protected abstract void query1();</span><br><span class="line">abstract void query2();</span><br><span class="line"></span><br><span class="line">//包含普通方法</span><br><span class="line">public void ss() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class testAbstract extends AbstractClass&#123;</span><br><span class="line">@Override</span><br><span class="line">public void query() &#123;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void query1() &#123;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void query2() &#123;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void ss() &#123;</span><br><span class="line">super.ss();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java-8中抽象类与接口的异同&quot;&gt;&lt;a href=&quot;#Java-8中抽象类与接口的异同&quot; class=&quot;headerlink&quot; title=&quot;Java 8中抽象类与接口的异同&quot;&gt;&lt;/a&gt;Java 8中抽象类与接口的异同&lt;/h3&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://lastsummer.top/blog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础面试题四</title>
    <link href="https://lastsummer.top/blog/2019/10/10/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9B/"/>
    <id>https://lastsummer.top/blog/2019/10/10/JAVA基础面试题四/</id>
    <published>2019-10-10T05:57:01.000Z</published>
    <updated>2019-10-16T08:53:40.640Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本文主要JAVA基础面试题四"><a href="#本文主要JAVA基础面试题四" class="headerlink" title="本文主要JAVA基础面试题四"></a>本文主要JAVA基础面试题四</h3><a id="more"></a><h4 id="Class-forName的作用-为什么要用"><a href="#Class-forName的作用-为什么要用" class="headerlink" title="Class.forName的作用?为什么要用?"></a>Class.forName的作用?为什么要用?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;&quot;)返回的是类</span><br><span class="line">Class.forName(&quot;&quot;).newInstance()返回的是object</span><br><span class="line">A a = (A)Class.forName(&quot;pacage.A&quot;).newInstance(); </span><br><span class="line">动态加载和创建Class 对象，比如想根据用户输入的字符串来创建对象。</span><br><span class="line">jvm会执行静态代码段，你要记住一个概念，静态代码是和class绑定的，class装载成功就表示执行了你的静态代码了。而且以后不会再走这段静态代码了。</span><br><span class="line">第一是CLASSPATH下指定名字的.class文件加载到Java虚拟机内存中</span><br><span class="line">第二是初始化这个类</span><br><span class="line">一.首先你要明白在java里面任何class都要装载在虚拟机上才能运行。</span><br><span class="line"> 1.forName这句话就是装载类用的(new是根据加载到内存中的类创建一个实例，要分清楚)。 </span><br><span class="line"> 2.至于什么时候用，可以考虑一下这个问题，给你一个字符串变量，它代表一个类的包名和类名，你怎么实例化它？</span><br><span class="line"> A a = (A)Class.forName(&quot;pacage.A&quot;).newInstance();这和 A a =new A();是一样的效果。</span><br><span class="line"> 3.jvm在装载类时会执行类的静态代码段，要记住静态代码是和class绑定的，class装载成功就表示执行了你的静态代码了，而且以后不会再执行这段静态代码了。</span><br><span class="line"> 4.Class.forName(xxx.xx.xx)的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。</span><br><span class="line"> 5. 动态加载和创建Class 对象，比如想根据用户输入的字符串来创建对象</span><br><span class="line">二.在初始化一个类，生成一个实例的时候，newInstance()方法和new关键字除了一个是方法，一个是关键字外，最主要有什么区别？</span><br><span class="line"> 1.它们的区别在于创建对象的方式不一样，前者是使用类加载机制，后者是创建一个新类。</span><br><span class="line"> 2.那么为什么会有两种创建对象方式？</span><br><span class="line"> 这主要考虑到软件的可伸缩、可扩展和可重用等软件设计思想。 </span><br><span class="line"> 3.从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。 但是使用newInstance()方法的时候，必须保证这个类已经加载且这个类已经连接了。</span><br><span class="line">三.最后用最简单的描述来区分new关键字和newInstance()方法的区别： </span><br><span class="line"> 1. newInstance: 弱类型。低效率。只能调用无参构造。 </span><br><span class="line"> 2. new: 强类型。相对高效。能调用任何public构造。</span><br></pre></td></tr></table></figure><h4 id="Servlet介绍？-单例多线程"><a href="#Servlet介绍？-单例多线程" class="headerlink" title="Servlet介绍？(单例多线程)"></a>Servlet介绍？(单例多线程)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">servlet的生命周期由servlet容器控制，该容器创建servlet的实例。servlet的生命周期就是指servlet实例在创建之后响应客户端请求直至销毁的全过程。</span><br><span class="line">servlet实例的首次创建取决于servlet的首次调用。servlet接口定义了servlet生命周期的三个方法，这些方法就是init(),service(),destroy().</span><br><span class="line">（1）init()方法用来把servlet导入和初始化。这个方法在servlet被预加载或在第一次请求时执行。</span><br><span class="line">（2）servlet处理0个或多个请求。servlet对每个方法都用service()方法来处理。</span><br><span class="line">（3）当web应用声明servlet被关闭、servlet被销毁、垃圾收集器对资源进行收集时，用destroy()方法来关闭servlet。    </span><br><span class="line">高并发、不安全</span><br><span class="line">只存在一个servlet、多个线程同时请求实例变量、非线程安全</span><br><span class="line">如何做到线程安全？</span><br><span class="line">1.实现SingleThreadModel接口</span><br><span class="line">2.synchronized关键字加锁lock</span><br><span class="line">3.尽量不使用实例变量</span><br></pre></td></tr></table></figure><h4 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java语言中关键字 volatile 被称作轻量级的 synchronized</span><br><span class="line">用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最新的值。</span><br><span class="line">volatile很容易被误用，用来进行原子性操作，它不能保证多个线程修改的安全性。</span><br><span class="line">Java可以使用volatile关键字，确保每个线程对本地变量的访问和修改都直接与主内存交互，而不是与本地线程的工作内存交互的，保证每个线程都能获得最新的值。</span><br></pre></td></tr></table></figure><p><img src="/blog/2019/10/10/JAVA基础面试题四/java1.png" alt=""></p><h4 id="和equals的区别？"><a href="#和equals的区别？" class="headerlink" title="==和equals的区别？"></a>==和equals的区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)对于==，比较的是值是否相等</span><br><span class="line"> 如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</span><br><span class="line"> 如果作用于引用类型的变量，则比较的是所指向的对象的地址</span><br><span class="line">(2)对于equals方法，注意：equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象</span><br><span class="line"> 如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</span><br><span class="line"> 诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</span><br></pre></td></tr></table></figure><h4 id="数组有没有length-方法？string没有lenght-方法？"><a href="#数组有没有length-方法？string没有lenght-方法？" class="headerlink" title="数组有没有length()方法？string没有lenght()方法？"></a>数组有没有length()方法？string没有lenght()方法？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据没有length()，但有length属性</span><br><span class="line">string有length()方法</span><br></pre></td></tr></table></figure><h4 id="服务代理后获取真实ip地址"><a href="#服务代理后获取真实ip地址" class="headerlink" title="服务代理后获取真实ip地址"></a>服务代理后获取真实ip地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java获取客户端IP地址的方法为request.getRemoteAddr()。</span><br><span class="line">request.getHeader(&quot;x-forwarded-for&quot;)</span><br><span class="line">request.getHeader(&quot;Proxy-Client-IP&quot;)</span><br><span class="line">request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br></pre></td></tr></table></figure><h4 id="Oracle和Mysql的区别"><a href="#Oracle和Mysql的区别" class="headerlink" title="Oracle和Mysql的区别"></a>Oracle和Mysql的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、关系型数据库</span><br><span class="line">2、Oracle收费、Mysql开源</span><br><span class="line">3、Oracle一个实例对应多个用户</span><br><span class="line">  Mysql一个用户对应多个数据库</span><br><span class="line">4、与Oracle相比，MySQL没有表空间，角色管理，快照，同义词和包以及自动存储管理。</span><br></pre></td></tr></table></figure><h4 id="Vue和JQuery区别"><a href="#Vue和JQuery区别" class="headerlink" title="Vue和JQuery区别"></a>Vue和JQuery区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、Vue比JQuery减少了 DOM 操作</span><br><span class="line">2、Vue支持双向数据绑定及组件化</span><br><span class="line">3、jquery 是javacript库，封装了一些js常用的方法。（动态效果）</span><br><span class="line">  vue 是一个前端框架，vue有成熟的生态链，mvvm模式，是一个真正的web框架（单页面开发）。</span><br></pre></td></tr></table></figure><h4 id="JWT和Token区别"><a href="#JWT和Token区别" class="headerlink" title="JWT和Token区别"></a>JWT和Token区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">token一个字符串。每次客户端保存localstore，每次请求放入到http head请求头中进行访问（Bearer），服务器查询数据库验证信息是否正确</span><br><span class="line">相同： </span><br><span class="line">都是访问资源的令牌， 都可以记录用户信息，都是只有验证成功后</span><br><span class="line">区别：</span><br><span class="line">​服务端验证客户端发来的token信息要进行数据的查询操作；</span><br><span class="line">JWT验证客户端发来的token信息就不用， 在服务端使用密钥校验就可以，不用数据库的查询。</span><br><span class="line">JWT（请求头【类型jwt+hs256算法加密】、载荷【预定义声明+自定义声明userid+签名】、签名）</span><br><span class="line">base64请求头+base64载荷+签名【(base64请求头+base64载荷)hash算法】组成两个点的字符串（secret解密）</span><br></pre></td></tr></table></figure><h4 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动jar包</span><br><span class="line">nginx日志切割</span><br></pre></td></tr></table></figure><h4 id="Git冲突处理方案"><a href="#Git冲突处理方案" class="headerlink" title="Git冲突处理方案"></a>Git冲突处理方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当Git merge无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</span><br><span class="line">把修改的文件复制出来、先pull在修改。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本文主要JAVA基础面试题四&quot;&gt;&lt;a href=&quot;#本文主要JAVA基础面试题四&quot; class=&quot;headerlink&quot; title=&quot;本文主要JAVA基础面试题四&quot;&gt;&lt;/a&gt;本文主要JAVA基础面试题四&lt;/h3&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://lastsummer.top/blog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Web相关优化</title>
    <link href="https://lastsummer.top/blog/2019/10/09/Web%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/"/>
    <id>https://lastsummer.top/blog/2019/10/09/Web相关优化/</id>
    <published>2019-10-09T01:24:13.000Z</published>
    <updated>2019-10-16T07:55:20.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Web相关优化"><a href="#Web相关优化" class="headerlink" title="Web相关优化"></a>Web相关优化</h3><a id="more"></a><h4 id="表现层页面的优化"><a href="#表现层页面的优化" class="headerlink" title="表现层页面的优化"></a>表现层页面的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">尽量使用静态HTML页面</span><br><span class="line">不使用FLASH、图片</span><br><span class="line">尽量使用DIV、不将整个页面放入TABLE中</span><br><span class="line">将javascript放入到js文件中</span><br><span class="line">使用IFrame嵌套另一个页面，和主页面分开加载，不影响页面加载速度</span><br><span class="line">CSS放在头部、JS脚本放在底部加载</span><br><span class="line">对于访问量高的页面，设计缓存方案，经常访问的数据缓存起来</span><br><span class="line">优化重要的公共模块、高度集成提示信息</span><br></pre></td></tr></table></figure><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis分布式缓存</span><br><span class="line">ehcache、oscache缓存</span><br><span class="line">hibernate二级缓存</span><br><span class="line">前端静态js、css、样式文件缓存</span><br></pre></td></tr></table></figure><h4 id="数据库的优化"><a href="#数据库的优化" class="headerlink" title="数据库的优化"></a>数据库的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据库的优化(读写分离、分区、分表、缓存、索引、视图、存储过程等)</span><br><span class="line">sql优化</span><br></pre></td></tr></table></figure><h4 id="服务器的优化"><a href="#服务器的优化" class="headerlink" title="服务器的优化"></a>服务器的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">外部环境优化：</span><br><span class="line">（1）java虚拟机的优化、尽量采用最新的版本、设置java虚拟机的内存参数</span><br><span class="line">服务器自身的优化：</span><br><span class="line">（1）Tomcat 例如：设置线程数量、JSP编译速度、防止恶意攻击、压缩</span><br><span class="line"> 1、优化Tomcat的JVM环境内存优化</span><br><span class="line">2、优化tomcat线程池</span><br><span class="line">3、禁用DNS查询 enableLookups=&quot;false&quot;</span><br><span class="line">4、session过期时间</span><br><span class="line">5、Apr插件提高Tomcat性能</span><br><span class="line">6、压缩</span><br><span class="line">7、文字转码UTF-8</span><br><span class="line">（2）Nginx </span><br><span class="line">1、expires缓存模块、网页缓存</span><br><span class="line">2、gzip压缩模块</span><br><span class="line">3、隐藏版本号</span><br><span class="line">4、日志切割</span><br><span class="line">5、设置连接超时、进程数、配置防盗链</span><br><span class="line">6、动静分离</span><br><span class="line">7、代理http跳转https这块配置  </span><br><span class="line">8、nginx添加用户组</span><br><span class="line">9、最多可以打开文件数</span><br></pre></td></tr></table></figure><h4 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">负载均衡：</span><br><span class="line">是大型网站解决高负荷访问和大量并发请求采用的最终解决办法</span><br><span class="line">与图片服务器分离：</span><br><span class="line">设置独立的图片服务器，可以降低web应用的服务器的压力，保证系统不会因为图片问题二奔溃(优化)</span><br></pre></td></tr></table></figure><h4 id="减少外部http协议"><a href="#减少外部http协议" class="headerlink" title="减少外部http协议"></a>减少外部http协议</h4><h4 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。</span><br><span class="line">简单的来说，就是把原服务器上数据复制到其他服务器上，用户访问时，那台服务器近访问到的就是那台服务器上的数据。CDN加速优点是成本低，速度快。适合访问量比较大的网站。</span><br></pre></td></tr></table></figure><h4 id="echarts简单优化？"><a href="#echarts简单优化？" class="headerlink" title="echarts简单优化？"></a>echarts简单优化？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">模块复用</span><br><span class="line">缓存</span><br><span class="line">关闭动画（3D）</span><br><span class="line">SQL优化</span><br><span class="line">可选择 dataZoom</span><br><span class="line">type为line时可选择sampling</span><br><span class="line">懒加载（逐步加载）echarts模块或图片lazyload</span><br><span class="line">清理不用的图表、clear和dispose</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Web相关优化&quot;&gt;&lt;a href=&quot;#Web相关优化&quot; class=&quot;headerlink&quot; title=&quot;Web相关优化&quot;&gt;&lt;/a&gt;Web相关优化&lt;/h3&gt;
    
    </summary>
    
      <category term="WEB" scheme="https://lastsummer.top/blog/categories/WEB/"/>
    
    
      <category term="web" scheme="https://lastsummer.top/blog/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础面试题三</title>
    <link href="https://lastsummer.top/blog/2019/10/07/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%89/"/>
    <id>https://lastsummer.top/blog/2019/10/07/JAVA基础面试题三/</id>
    <published>2019-10-07T12:53:37.000Z</published>
    <updated>2019-10-09T01:30:45.179Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本文主要JAVA基础面试题三"><a href="#本文主要JAVA基础面试题三" class="headerlink" title="本文主要JAVA基础面试题三"></a>本文主要JAVA基础面试题三</h3><a id="more"></a><h4 id="JDK、JRE、JVM三者间的关系？"><a href="#JDK、JRE、JVM三者间的关系？" class="headerlink" title="JDK、JRE、JVM三者间的关系？"></a>JDK、JRE、JVM三者间的关系？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JDK:Java运行环境JRE、Java工具和Java基础类库。</span><br><span class="line">JRE:运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。</span><br><span class="line">JVM:整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。</span><br></pre></td></tr></table></figure><h4 id="amp-和-amp-amp-的区别？"><a href="#amp-和-amp-amp-的区别？" class="headerlink" title="&amp; 和 &amp;&amp; 的区别？"></a>&amp; 和 &amp;&amp; 的区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and）。</span><br><span class="line">不同点：</span><br><span class="line">(1)&amp;&amp;具有短路的功能，而&amp;不具备短路功能。</span><br><span class="line">(2)当&amp;运算符两边的表达式的结果都为true时，整个运算结果才为true。而&amp;&amp;运算符第一个表达式为false时，则结果为false，不再计算第二个表达式。</span><br><span class="line">(3)&amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如：0x31 &amp; 0x0f的结果为0x01。</span><br><span class="line">5 &amp; 4  4</span><br><span class="line">00000101</span><br><span class="line">00000100</span><br><span class="line">00000100</span><br></pre></td></tr></table></figure><h4 id="a-b与a-a-b的区别？"><a href="#a-b与a-a-b的区别？" class="headerlink" title="a+=b与a=a+b的区别？"></a>a+=b与a=a+b的区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)byte、short类型的数相加、都会提升为int类型</span><br><span class="line">(2)=+赋值运算符 自动类型转换，也称隐式类型转换，是指不需要书写代码，由系统自动完成的类型转换。</span><br><span class="line">从存储范围小的类型到存储范围大的类型。</span><br><span class="line">具体规则为：</span><br><span class="line">short(char)→int→long→float→double</span><br><span class="line">+算数运算符</span><br></pre></td></tr></table></figure><h4 id="如何不使用第三个变量，交换变量a，b的值？"><a href="#如何不使用第三个变量，交换变量a，b的值？" class="headerlink" title="如何不使用第三个变量，交换变量a，b的值？"></a>如何不使用第三个变量，交换变量a，b的值？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br><span class="line"></span><br><span class="line">a = b + (b = a)0;</span><br></pre></td></tr></table></figure><h4 id="求最大公约数？"><a href="#求最大公约数？" class="headerlink" title="求最大公约数？"></a>求最大公约数？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//求出两个数字之间的小值</span><br><span class="line">int min = a &lt; b ? a : b;</span><br><span class="line"></span><br><span class="line">for (int i = min;i &gt;= 1;i --) &#123;</span><br><span class="line">    if (a % i == 0 &amp;&amp; b % i == 0) &#123;</span><br><span class="line">        System.out.println(&quot;最大公约数是：&quot; + i);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符流和字节流的区别"><a href="#字符流和字节流的区别" class="headerlink" title="字符流和字节流的区别?"></a>字符流和字节流的区别?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字符流：用于处理文字和字符的 流。操作完成后不关闭流，数据无法传递。采用Unicode编码，由字符组成，1字符=2字节。</span><br><span class="line">字节流：文字以外的都可以用。操作完成后不需关闭流，也可以传递数据。采用ASCII编码,按字节处理。</span><br><span class="line">字符流有缓冲区，将数据接受于缓冲区，达到区的极限（通过手动 1.colse 2.flush）就会进入文件中，打开文件次数少。</span><br><span class="line">字节流：每传一次数据就会打开一次文件，打开数据次数多。占用内存。</span><br></pre></td></tr></table></figure><h4 id="类和对象的区别？"><a href="#类和对象的区别？" class="headerlink" title="类和对象的区别？"></a>类和对象的区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java面对对象开发。</span><br><span class="line">类是对象的抽象，而对象是类的具体实例。</span><br><span class="line">类的实例化结果就是对象。</span><br></pre></td></tr></table></figure><h4 id="drop、truncate、delete区别？"><a href="#drop、truncate、delete区别？" class="headerlink" title="drop、truncate、delete区别？"></a>drop、truncate、delete区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop：将表所占用的空间全释放掉。</span><br><span class="line">truncate：不会触发触发器、执行速度快、初始化索引和表、不能回滚。只能对table</span><br><span class="line">delete：每次删除一行触发触发器，记入日志保存、可以添加条件、必须commit、存在缓存区、可以回退。可以是table和view。</span><br></pre></td></tr></table></figure><h4 id="JS中3种弹出窗口函数区别分析？"><a href="#JS中3种弹出窗口函数区别分析？" class="headerlink" title="JS中3种弹出窗口函数区别分析？"></a>JS中3种弹出窗口函数区别分析？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.alert：只有一个显示警告框的信息,无返回值；</span><br><span class="line">window.confirm：就一个参数即提示信息，有返回值 true或false；</span><br><span class="line">window.prompt：有两个参数，第一个显示提示信息，第二个显示输入框的默认值；</span><br></pre></td></tr></table></figure><h4 id="内存溢出和内存泄漏的区别？"><a href="#内存溢出和内存泄漏的区别？" class="headerlink" title="内存溢出和内存泄漏的区别？"></a>内存溢出和内存泄漏的区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内存溢出：</span><br><span class="line">系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出。</span><br><span class="line">内存泄漏：</span><br><span class="line">意思就是你用资源的时候为他开辟了一段空间，当你用完时忘记释放资源了，这时内存还被占用着，一次没关系，但是内存泄漏次数多了就会导致内存溢出。</span><br><span class="line">(1)for缓存、while(true)代码中存在死循环或循环产生过多重复的对象实体； </span><br><span class="line">(2)使用完后没有关闭资源；</span><br><span class="line">(3)重复创建对象；</span><br><span class="line">(4)内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</span><br><span class="line">(5)启动参数内存值设定的过小；</span><br><span class="line">(6)使用的第三方软件中的BUG；</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本文主要JAVA基础面试题三&quot;&gt;&lt;a href=&quot;#本文主要JAVA基础面试题三&quot; class=&quot;headerlink&quot; title=&quot;本文主要JAVA基础面试题三&quot;&gt;&lt;/a&gt;本文主要JAVA基础面试题三&lt;/h3&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://lastsummer.top/blog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础面试题二</title>
    <link href="https://lastsummer.top/blog/2019/10/07/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/"/>
    <id>https://lastsummer.top/blog/2019/10/07/JAVA基础面试题二/</id>
    <published>2019-10-07T01:24:39.000Z</published>
    <updated>2019-10-07T03:37:22.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本文主要JAVA基础面试题二（二叉树）"><a href="#本文主要JAVA基础面试题二（二叉树）" class="headerlink" title="本文主要JAVA基础面试题二（二叉树）"></a>本文主要JAVA基础面试题二（二叉树）</h3><a id="more"></a><h4 id="树的介绍？"><a href="#树的介绍？" class="headerlink" title="树的介绍？"></a>树的介绍？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)、每个结点有零个或多个子节点</span><br><span class="line">(2)、设有父节点的结点称为根节点</span><br><span class="line">(3)、每一个非根结点有且只有一个父节点</span><br><span class="line">(4)、除了根节点外，每个子结点可以分为多个不相交的子树</span><br></pre></td></tr></table></figure><h4 id="二叉树的介绍？"><a href="#二叉树的介绍？" class="headerlink" title="二叉树的介绍？"></a>二叉树的介绍？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)、二叉树是每个结点最多有两个子树的结构</span><br><span class="line">(2)、基本形态：可以是空集、根可以有空的左右树、或者左、右树</span><br><span class="line">(3)、每一个非根结点有且只有一个父节点</span><br><span class="line">(4)、除了根节点外，每个子结点可以分为多个不相交的子树</span><br></pre></td></tr></table></figure><h4 id="二叉查找树有哪些特性？"><a href="#二叉查找树有哪些特性？" class="headerlink" title="二叉查找树有哪些特性？"></a>二叉查找树有哪些特性？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)、左子树上所有的节点的值均小于或等于他的根节点的值</span><br><span class="line">(2)、右子数上所有的节点的值均大于或等于他的根节点的值</span><br><span class="line">(3)、左右子树也一定分别为二叉排序树</span><br></pre></td></tr></table></figure><h4 id="红黑树的特性？-自平衡二叉查找树-自平衡：左旋、右旋和变色"><a href="#红黑树的特性？-自平衡二叉查找树-自平衡：左旋、右旋和变色" class="headerlink" title="红黑树的特性？(自平衡二叉查找树,自平衡：左旋、右旋和变色)"></a>红黑树的特性？(自平衡二叉查找树,自平衡：左旋、右旋和变色)</h4><p>红黑树就是一种平衡的二叉查找树，说他平衡的意思是他不会变成“瘸子”，左腿特别长或者右腿特别长。<br>除了符合二叉查找树的特性之外，还具体下列的特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)、节点是红色或者黑色</span><br><span class="line">(2)、根节点是黑色</span><br><span class="line">(3)、每个叶子的节点都是黑色的空节点（NULL）</span><br><span class="line">(4)、每个红色节点的两个子节点都是黑色的。</span><br><span class="line">(5)、从任意节点到其每个叶子的所有路径都包含相同的黑色节点。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本文主要JAVA基础面试题二（二叉树）&quot;&gt;&lt;a href=&quot;#本文主要JAVA基础面试题二（二叉树）&quot; class=&quot;headerlink&quot; title=&quot;本文主要JAVA基础面试题二（二叉树）&quot;&gt;&lt;/a&gt;本文主要JAVA基础面试题二（二叉树）&lt;/h3&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://lastsummer.top/blog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础面试题一</title>
    <link href="https://lastsummer.top/blog/2019/10/04/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/"/>
    <id>https://lastsummer.top/blog/2019/10/04/JAVA基础面试题一/</id>
    <published>2019-10-04T00:55:44.000Z</published>
    <updated>2019-10-08T01:07:40.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本文主要JAVA基础面试题一"><a href="#本文主要JAVA基础面试题一" class="headerlink" title="本文主要JAVA基础面试题一"></a>本文主要JAVA基础面试题一</h3><a id="more"></a><h4 id="如何跳出的多重嵌套循环？"><a href="#如何跳出的多重嵌套循环？" class="headerlink" title="如何跳出的多重嵌套循环？"></a>如何跳出的多重嵌套循环？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">（1）在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号</span><br><span class="line">public static void method1()&#123;</span><br><span class="line">ok:for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;10;j++)&#123;</span><br><span class="line">System.out.println(&quot;i=&quot;+i+&quot;,j=&quot;+j);</span><br><span class="line">if(j==5)&#123;</span><br><span class="line">break ok;//跳到循环外的ok出，即终止整个循环</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">（2）也可以在里层循环体的代码中使用带有标号的break语句，即可跳出外层循环</span><br><span class="line">public static void method2()&#123;</span><br><span class="line">int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;9&#125;&#125;;</span><br><span class="line">boolean found = false;</span><br><span class="line">for(int i=0;i&lt;arr.length &amp;&amp; !found;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">System.out.println(&quot;i=&quot;+i+&quot;,j=&quot;+j);</span><br><span class="line">if(arr[i][j]==5)&#123;</span><br><span class="line">found = true;//找到5，使外层循环判断条件变为false则终止整个循环</span><br><span class="line">break;//跳出当前循环</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态变量和实例变量的区别？"><a href="#静态变量和实例变量的区别？" class="headerlink" title="静态变量和实例变量的区别？"></a>静态变量和实例变量的区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）：首先在语法定义上区别：静态变量前面要加static，实例变量不用</span><br><span class="line">（2）：在程序运行时：实例变量输入对象的属性，必须创建了实例对象（如 new）才会被分配空间，才可以使用实例变量，</span><br><span class="line">  静态变量不属于某个实例对象，而是属于类，也叫类变量，只要程序加载了类的字节码，不用创建任何实例对象就会被分配空间，就可以被使用</span><br><span class="line">（3）：总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</span><br></pre></td></tr></table></figure><h4 id="堆和栈的区别在什么地方？"><a href="#堆和栈的区别在什么地方？" class="headerlink" title="堆和栈的区别在什么地方？"></a>堆和栈的区别在什么地方？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">堆（一般存放对象本身，block的copy等）</span><br><span class="line">（1）Java的堆是一个运行时数据区，类的对象从堆中分配空间。这些对象通过new等指令建立，通过垃圾回收器来销毁。</span><br><span class="line">（2）堆的优势是可以动态地分配内存空间，需要多少内存空间不必事先告诉编译器，因为它是在运行时动态分配的。但缺点是，由于需要在运行时动态分配内存，所以存取速度较慢。</span><br><span class="line">栈:后进先出（一般存储基本数据类型，对象的地址）</span><br><span class="line">（1）栈中主要存放一些基本数据类型的变量（byte，short，int，long，float，double，boolean，char）和对象的引用。</span><br><span class="line">（2）栈的优势是，存取速度比堆快，栈数据可以共享。但缺点是，存放在栈中的数据占用多少内存空间需要在编译时确定下来，缺乏灵活性。</span><br></pre></td></tr></table></figure><h4 id="类的实例化顺序"><a href="#类的实例化顺序" class="headerlink" title="类的实例化顺序?"></a>类的实例化顺序?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">父类静态代变量</span><br><span class="line">父类静态代码块</span><br><span class="line">子类静态变量</span><br><span class="line">子类静态代码块</span><br><span class="line">父类非静态变量（父类实例成员变量）</span><br><span class="line">父类构造函数</span><br><span class="line">子类非静态变量（子类实例成员变量）</span><br><span class="line">子类构造函数</span><br></pre></td></tr></table></figure><h4 id="集合区别？"><a href="#集合区别？" class="headerlink" title="集合区别？"></a>集合区别？</h4><p><img src="/blog/2019/10/04/JAVA基础面试题一/java1.png" alt=""></p><h4 id="http-https协议？"><a href="#http-https协议？" class="headerlink" title="http,https协议？"></a>http,https协议？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP：</span><br><span class="line">是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</span><br><span class="line">HTTPS：</span><br><span class="line">是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</span><br><span class="line">区别：</span><br><span class="line">1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</span><br><span class="line">2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</span><br><span class="line">3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</span><br><span class="line">4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</span><br></pre></td></tr></table></figure><h4 id="常见到的runtime-exception？"><a href="#常见到的runtime-exception？" class="headerlink" title="常见到的runtime exception？"></a>常见到的runtime exception？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">空指针：NullPointerException</span><br><span class="line">类型转换失败：ClassCastException</span><br><span class="line">文件找不到：FileNotFoundException</span><br><span class="line">数组下标越界：ArrayIndexOutOfBoundsException</span><br><span class="line">类找不到：ClassNotFoundException</span><br><span class="line">字符串转换为数字异常：NumberFormatException</span><br><span class="line">方法未找到异常：NoSuchMethodException</span><br><span class="line">字符串索引越界异常：StringIndexOutOfBoundsException</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java的基本数据类型转换规则，大的数据类型转换为小的数据类型需要强制转换，反之可以自动转换</span><br></pre></td></tr></table></figure><h4 id="char能存贮一个中文汉字-为什么"><a href="#char能存贮一个中文汉字-为什么" class="headerlink" title="char能存贮一个中文汉字?为什么"></a>char能存贮一个中文汉字?为什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</span><br></pre></td></tr></table></figure><h4 id="abstractclass和interface区别"><a href="#abstractclass和interface区别" class="headerlink" title="abstractclass和interface区别"></a>abstractclass和interface区别</h4><p><img src="/blog/2019/10/04/JAVA基础面试题一/java2.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本文主要JAVA基础面试题一&quot;&gt;&lt;a href=&quot;#本文主要JAVA基础面试题一&quot; class=&quot;headerlink&quot; title=&quot;本文主要JAVA基础面试题一&quot;&gt;&lt;/a&gt;本文主要JAVA基础面试题一&lt;/h3&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://lastsummer.top/blog/categories/JAVA/"/>
    
    
      <category term="java" scheme="https://lastsummer.top/blog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Nginx日志切割</title>
    <link href="https://lastsummer.top/blog/2019/07/08/Nginx%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/"/>
    <id>https://lastsummer.top/blog/2019/07/08/Nginx日志切割/</id>
    <published>2019-07-08T05:19:12.000Z</published>
    <updated>2019-07-08T06:24:49.478Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Nginx日志切割"><a href="#Nginx日志切割" class="headerlink" title="Nginx日志切割"></a>Nginx日志切割<a id="more"></a></h4><p>nginx版本：1.8.1<br>nginx目录：/usr/local/nginx/<br>nginx日志：/usr/local/nginx/logs<br>    acces.log    #访问量<br>    error.log    #错误日志<br>    pid.log        #NGINX进程ID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 获取昨天的access日志</span><br><span class="line">mv access.log &apos;date +%F -d -1day&apos;_access.log</span><br><span class="line"># 重新打开日志文件</span><br><span class="line">/usr/local/nginx/sbin/nginx -s reopen</span><br></pre></td></tr></table></figure><p>完整代码<br><code>/usr/local/nginx/logs新建backup.sh命令并且vim编辑</code><br><code>/usr/local/nginx/logs/新建oldLogs文件夹</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 备份日志文件夹（旧的日志）</span><br><span class="line">LOGS_PATH=/usr/local/nginx/logs/oldLogs</span><br><span class="line"># 当前日志文件夹（新的日志）</span><br><span class="line">CUR_LOGS_PATH=/usr/local/nginx/logs</span><br><span class="line"># 昨天的日期</span><br><span class="line">YESTERDAY=$(date +%F -d -1day)</span><br><span class="line"># 备份access.log</span><br><span class="line">mv $CUR_LOGS_PATH/access.log $LOGS_PATH/$&#123;YESTERDAY&#125;_access.log</span><br><span class="line"># 备份error.log</span><br><span class="line">mv $CUR_LOGS_PATH/error.log $LOGS_PATH/$&#123;YESTERDAY&#125;_error.log</span><br><span class="line"># 重新打开日志文件</span><br><span class="line">kill -USR1 $(cat /usr/local/nginx/logs/nginx.pid)</span><br><span class="line"># USR1 通常被用来告知应用程序重载配置文件</span><br></pre></td></tr></table></figure></p><p>执行<code>sh backup.sh</code>即可在oldLogs下生成昨天日志（完成）</p><h4 id="定时任务自动执行shell脚本"><a href="#定时任务自动执行shell脚本" class="headerlink" title="定时任务自动执行shell脚本"></a>定时任务自动执行shell脚本</h4><p><code>crontab -e</code>    #编辑定时任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * /bin/bash /usr/local/nginx/logs/backup.sh</span><br></pre></td></tr></table></figure></p><p><code>crontab -l</code>    #查看编辑任务<br><code>0 0 * * *</code>每天执行一次生成昨天的日志</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Nginx日志切割&quot;&gt;&lt;a href=&quot;#Nginx日志切割&quot; class=&quot;headerlink&quot; title=&quot;Nginx日志切割&quot;&gt;&lt;/a&gt;Nginx日志切割&lt;/h4&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://lastsummer.top/blog/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://lastsummer.top/blog/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置Https遇到的问题</title>
    <link href="https://lastsummer.top/blog/2019/07/06/Nginx%E9%85%8D%E7%BD%AEHttps%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://lastsummer.top/blog/2019/07/06/Nginx配置Https遇到的问题/</id>
    <published>2019-07-06T04:44:44.000Z</published>
    <updated>2019-07-06T05:50:05.424Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nginx配置Https-开启例外443端口"><a href="#Nginx配置Https-开启例外443端口" class="headerlink" title="Nginx配置Https 开启例外443端口"></a>Nginx配置Https 开启例外443端口</h3><a id="more"></a><h4 id="Nginx如果未开启SSL模块，配置Https时提示错误"><a href="#Nginx如果未开启SSL模块，配置Https时提示错误" class="headerlink" title="Nginx如果未开启SSL模块，配置Https时提示错误"></a>Nginx如果未开启SSL模块，配置Https时提示错误</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] the &quot;ssl&quot; parameter requires ngx_http_ssl_module in /usr/local/nginx/conf/nginx.conf:37</span><br></pre></td></tr></table></figure><p>nginx缺少http_ssl_module模块，编译安装的时候带上–with-http_ssl_module配置就行了</p><h4 id="Nginx开启SSL模块（重新编译）"><a href="#Nginx开启SSL模块（重新编译）" class="headerlink" title="Nginx开启SSL模块（重新编译）"></a>Nginx开启SSL模块（重新编译）</h4><p>Nginx源码包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx-1.8.1</span><br></pre></td></tr></table></figure></p><p>查看Nginx已安装的模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure></p><p>重新编译安装nginx（必须停止Nginx）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 停止Nginx</span><br><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line"></span><br><span class="line"># 重新编译Nginx</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</span><br><span class="line"></span><br><span class="line"># Nginx编译(不要进行make install，否则就是覆盖安装Nginx)</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"># 然后备份原有已安装好的nginx</span><br><span class="line">cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</span><br><span class="line"></span><br><span class="line"># 然后将刚刚编译好的nginx覆盖掉原有的nginx（这个时候nginx要停止状态）</span><br><span class="line">cp ./objs/nginx /usr/local/nginx/sbin/</span><br><span class="line"></span><br><span class="line"># 然后启动nginx，仍可以通过命令查看是否已经加入成功</span><br><span class="line">/usr/local/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure></p><p><img src="/blog/2019/07/06/Nginx配置Https遇到的问题/nginx.png" alt="nginx -V"></p><h4 id="Nginx配置Https"><a href="#Nginx配置Https" class="headerlink" title="Nginx配置Https"></a>Nginx配置Https</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  web.tset.com;# 改为绑定证书的域名</span><br><span class="line">return 301 https://$server_name$request_uri;# 重定向https</span><br><span class="line">&#125;    </span><br><span class="line">server &#123;</span><br><span class="line">    listen       443;</span><br><span class="line">    server_name  web.tset.com;# 改为绑定证书的域名</span><br><span class="line">ssl on;</span><br><span class="line"># Nginx SSL性能调优</span><br><span class="line">ssl_certificate  cert/web.tset.com.pem;# 改为自己申请得到的 crt 文件的名称(新建cert目录)</span><br><span class="line">ssl_certificate_key cert/web.tset.com.key;# 改为自己申请得到的 key 文件的名称(新建cert目录)</span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">location / &#123;</span><br><span class="line">root html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启Nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure></p><h4 id="阿里云开启服务器443端口及80端口（https默认端口）"><a href="#阿里云开启服务器443端口及80端口（https默认端口）" class="headerlink" title="阿里云开启服务器443端口及80端口（https默认端口）"></a>阿里云开启服务器443端口及80端口（https默认端口）</h4><p>阿里云控制台=》云计算基础服务=》云服务器ECS=》网络和安全=》安全组，没有安全组的创建一个安全组，有的直接选择相应安全组，点击配置规则=》添加安全组规则（把80端口和443端口添加进安全组，授权对象填0.0.0.0/0）<br><img src="/blog/2019/07/06/Nginx配置Https遇到的问题/aliyun.png" alt="阿里云开启服务器443端口"></p><h4 id="阿里云申请SSL证书"><a href="#阿里云申请SSL证书" class="headerlink" title="阿里云申请SSL证书"></a>阿里云申请SSL证书</h4><p><a href="https://jingyan.baidu.com/article/6c67b1d6431a872787bb1ece.html" target="_blank" rel="noopener">教大家怎么申请阿里云的免费版 SSL证书</a></p><p>配置完成！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Nginx配置Https-开启例外443端口&quot;&gt;&lt;a href=&quot;#Nginx配置Https-开启例外443端口&quot; class=&quot;headerlink&quot; title=&quot;Nginx配置Https 开启例外443端口&quot;&gt;&lt;/a&gt;Nginx配置Https 开启例外443端口&lt;/h3&gt;
    
    </summary>
    
      <category term="Nginx" scheme="https://lastsummer.top/blog/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://lastsummer.top/blog/tags/Nginx/"/>
    
      <category term="SSL" scheme="https://lastsummer.top/blog/tags/SSL/"/>
    
      <category term="HTTPS" scheme="https://lastsummer.top/blog/tags/HTTPS/"/>
    
  </entry>
  
</feed>
