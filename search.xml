<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git基本命令]]></title>
    <url>%2Fblog%2F2019%2F03%2F04%2FGit%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git命令行基本操作！ git config可以配置git的参数1234567git config --list 查看已经配置的git参数git config --system user.name &quot;Tocy&quot; 所有用户（本系统）git config --system user.email zyvj@qq.com 所有用户（本系统）git config --global user.name &quot;Tocy&quot; 当前用户（全局）git config --global user.email zyvj@qq.com 当前用户（全局）git config --local user.name &quot;Tocy&quot; 本地配置（当前目录）git config --local user.email zyvj@qq.com 本地配置（当前目录） 创建Git仓库1git init 初始化当前目录 克隆Git仓库1git clone https://git.oschina.net/Tocy/SampleCode.git 基本命令1234567891011121314151617181920212223git status # 检查下修改了什么内容git log --stat # 仅显示摘要选项git log --pretty=oneline # 定制记录格式git log --graph # 图像化分支和版本更新git add . # 提交所有文件到暂存区git add Readme.mdgit add *.pnggit add /home/code/git diff # 查看当前目录的所有修改git commit -m &quot;注释备注&quot; # 提交代码到本地仓库git push # 提交代码到远程仓库git branch # 显示本地当前所有分支git branch -d test # 删除分支git branch -D test # 强制删除分支git checkout -b testing # 直接切换并创建分支git checkout master # 切换主分支git merge test # 合并分支的代码git branch -a # 查看远程仓库所有分支git push origin test # 推送本地分支到远程仓库git push origin --delete test # 删除远程分支git checkout &quot;git status项目文件路径&quot; # 还原某个文件git reset --hard &apos;git log中的commit id&apos; 还原所有文件到一个版本git pull # 更新远程仓库最新代码]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Calendar获取日期]]></title>
    <url>%2Fblog%2F2019%2F01%2F09%2FCalendar%E8%8E%B7%E5%8F%96%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Calendar获取月初月末日期。1234567891011121314151617181920212223242526SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);SimpleDateFormat startSimpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd 00:00:00&quot;);SimpleDateFormat EndDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd 23:59:59&quot;);//上月第一天Calendar calendar = Calendar.getInstance();System.out.println(&quot;当前时间：&quot;+simpleDateFormat.format(calendar.getTime()));calendar.add(Calendar.MONTH, -1);calendar.set(Calendar.DAY_OF_MONTH, 1);System.out.println(calendar.getTime());System.out.println(&quot;上月第一天时间：&quot;+startSimpleDateFormat.format(calendar.getTime()));//上月最后一天Calendar calendar1 = Calendar.getInstance();calendar1.set(Calendar.DAY_OF_MONTH, 1);calendar1.add(Calendar.DATE, -1);System.out.println(calendar1.getTime());System.out.println(&quot;上月最后一天：&quot;+EndDateFormat.format(calendar1.getTime()));//本月第一天Calendar calendar2 = Calendar.getInstance();calendar2.set(Calendar.DAY_OF_MONTH, calendar2.getActualMinimum(Calendar.DAY_OF_MONTH));System.out.println(calendar2.getTime());System.out.println(&quot;本月第一天：&quot;+startSimpleDateFormat.format(calendar2.getTime()));//本月最后一天Calendar calendar3 = Calendar.getInstance();calendar3.set(Calendar.DAY_OF_MONTH, calendar3.getActualMaximum(Calendar.DAY_OF_MONTH));System.out.println(calendar3.getTime());System.out.println(&quot;本月最后一天：&quot;+EndDateFormat.format(calendar3.getTime()));]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BigDecimal算法]]></title>
    <url>%2Fblog%2F2018%2F12%2F24%2FBigDecimal%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[BigDecimal算法。123456789101112131415161718192021222324252627282930313233343536373839404142434445BigDecimal bignum1 = new BigDecimal(&quot;10&quot;); BigDecimal bignum2 = new BigDecimal(&quot;5&quot;); BigDecimal bignum3 = null; //加法 bignum3 = bignum1.add(bignum2); System.out.println(&quot;和 是：&quot; + bignum3); //减法 bignum3 = bignum1.subtract(bignum2); System.out.println(&quot;差 是：&quot; + bignum3); //乘法 bignum3 = bignum1.multiply(bignum2); System.out.println(&quot;积 是：&quot; + bignum3); //除法 bignum3 = bignum1.divide(bignum2); System.out.println(&quot;商 是：&quot; + bignum3); //比较int bignum = bignum1.compareTo(bignum2);返回的结果是int类型，-1表示小于，0是等于，1是大于。BigDecimal decimal = new BigDecimal(&quot;1.12345&quot;);//保留四位小数，默认四舍五入BigDecimal setScale = decimal.setScale(4);System.out.println(setScale);//保留四位小数，直接删除多余的小数BigDecimal setScale = decimal.setScale(4,BigDecimal.ROUND_DOWN);System.out.println(setScale);//保留四位小数，进位处理BigDecimal setScale = decimal.setScale(4,BigDecimal.ROUND_UP);System.out.println(setScale);//保留四位小数，四舍五入（2.35变成2.4）BigDecimal setScale1= decimal.setScale(4,BigDecimal.ROUND_HALF_UP);System.out.println(setScale);//保留四位小数，四舍五入（2.35变成2.3）BigDecimal setScale = decimal.setScale(4,BigDecimal.ROUND_HALF_DOWN);System.out.println(setScale);]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle表恢复到特定时间点]]></title>
    <url>%2Fblog%2F2018%2F12%2F13%2FOracle%E8%A1%A8%E6%81%A2%E5%A4%8D%E5%88%B0%E7%89%B9%E5%AE%9A%E6%97%B6%E9%97%B4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Oracle数据库表恢复到特定时间点。12345678910111213141516171819-- Create tablecreate table TEST( id NUMBER(4), name VARCHAR2(20), class VARCHAR2(20), score NUMBER);-- Insert tableinsert into test values (11,&apos;测试10&apos;,&apos;一年三班&apos;,80);insert into test values (12,&apos;测试11&apos;,&apos;一年二班&apos;,90);insert into test values (13,&apos;测试12&apos;,&apos;一年一班&apos;,100);-- 数据库表恢复到特定时间点。select * from test as of timestamp to_timestamp(&apos;2018-12-13 10:18:00&apos;, &apos;yyyy-mm-dd hh24:mi:ss&apos;);-- 临时表恢复之前的数据create table 临时表 as select * from 你的那个数据被删除的表 as of timestamp to_timestamp(&apos;2013-08-13 14:00:00&apos;, &apos;yyyy-mm-dd hh24:mi:ss&apos;);]]></content>
      <categories>
        <category>ORACLE</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle查询各班前三名学生信息]]></title>
    <url>%2Fblog%2F2018%2F11%2F30%2FOracle%E6%9F%A5%E8%AF%A2%E5%90%84%E7%8F%AD%E5%89%8D%E4%B8%89%E5%90%8D%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[Oracle查询各班前三名学生的信息。row_number函数排序最好用它，每一行记录生成一个序号，依次排序且不会重复。rank函数返回结果集的分区内每行排名，行的排名是相关行之前的排名数加一，重复排序会重复。dense_rank函数的功能与rank函数类似，dense_rank函数在生成序号时是连续的，依次排序会重复。12345select * from (select rank() over(partition by class order by score desc nulls last)rank, s.*from test s) t where rank &lt;= 3 order by class asc, score desc; 12345select * from (select row_number()over(partition by class order by score desc nulls last) rank,s.*from test s) t where rank &lt;= 3 order by class asc, score desc 12345select * from (select dense_rank()over(partition by class order by score desc nulls last) rank,s.*from test s) t where rank &lt;= 3 order by class asc, score desc 关于Parttion by： Parttion by关键字是Oracle中分析性函数的一部分，用于给结果集进行分区。它和聚合函数Group by不同的地方在于它只是将原始数据进行名次排列，能够返回一个分组中的多条记录（记录数不变），而Group by是对原始数据进行聚合统计，一般只有一条反映统计值的结果（每组返回一条）。TIPS：使用rank over()的时候，空值是最大的，如果排序字段为null, 可能造成null字段排在最前面，影响排序结果。可以这样： rank over(partition by course order by score desc nulls last) 总结： 在使用排名函数的时候需要注意以下三点：1、排名函数必须有 OVER 子句。2、排名函数必须有包含 ORDER BY 的 OVER 子句。3、分组内从1开始排序。]]></content>
      <categories>
        <category>ORACLE</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java获得日期间的所有月份]]></title>
    <url>%2Fblog%2F2018%2F11%2F28%2FJava%E8%8E%B7%E5%BE%97%E6%97%A5%E6%9C%9F%E9%97%B4%E7%9A%84%E6%89%80%E6%9C%89%E6%9C%88%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[java获得两个日期之间的所有月份及日期之间的间隔。12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static List&lt;String&gt; getMonthBetween(String minDate, String maxDate) throws ParseException &#123; ArrayList&lt;String&gt; result = new ArrayList&lt;String&gt;(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM&quot;);//格式化为年月 Calendar min = Calendar.getInstance(); Calendar max = Calendar.getInstance(); min.setTime(sdf.parse(minDate)); min.set(min.get(Calendar.YEAR), min.get(Calendar.MONTH), 1); max.setTime(sdf.parse(maxDate)); max.set(max.get(Calendar.YEAR), max.get(Calendar.MONTH), 2); Calendar curr = max; while (min.before(curr)) &#123; result.add(sdf.format(curr.getTime())); curr.add(Calendar.MONTH, -1); &#125; //得到日期之间的间隔totalMonth Calendar calendarStart = Calendar.getInstance(); int startYear = calendarStart.get(Calendar.YEAR); int startMonth = calendarStart.get(Calendar.MONTH); Calendar calendarEnd = Calendar.getInstance(); calendarEnd.setTime(sdf.parse(maxDate)); int endYear = calendarEnd.get(Calendar.YEAR); int endMonth = calendarEnd.get(Calendar.MONTH); int totalMonth = 0; if (endYear &gt; startYear) &#123; totalMonth = (endYear-startYear)*12 +(endMonth - startMonth)+1; &#125;else if (endYear == startYear) &#123; totalMonth = endMonth - startMonth+1; &#125;else &#123; throw new ParameterException(&quot;结束时间不能小于开始时间&quot;); &#125; return result;&#125;public static void main(String[] args) throws ParseException &#123; List&lt;String&gt; list= getMonthBetween(&quot;2018-10&quot;,&quot;2019-10&quot;); for(String date : list) &#123; System.out.println(date); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git添加Tag用法]]></title>
    <url>%2Fblog%2F2018%2F11%2F14%2FGit%E6%B7%BB%E5%8A%A0Tag%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[作为版本管理工具，Git可以对某个版本打上标签(tag)，表示本版本为发行版。这样一个不可修改的历史代码版本就像被我们封存起来一样,不论是运维发布拉取,或者以后的代码版本管理,都是十分方便的。Git标签分为两类：1、轻量级的：它其实是一个独立的分支,或者说是一个不可变的分支.指向特定提交对象的引用2、带附注的：实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证,电子邮件地址和日期，一般我们都建议使用含附注型的标签，以便保留相关信息 查看标签打印所有标签1git tag 打印符合检索条件的标签1git tag -l &lt;版本号&gt; 如 git tag -l 1.*.* 为搜索一级版本为1的版本 查看对应标签状态1git checkout &lt;版本号&gt; 创建本地标签创建轻量标签轻量标签指向一个发行版的分支，其只是一个像某commit的引用，不存储名称时间戳及标签说明等信息。定义方法如下1git tag &lt;版本号&gt;-light 创建带附注标签相对于轻量标签，附注标签是一个独立的标签对象，包含了名称时间戳以及标签备注等信息，同时指向对应的commit。定义方法如下1git tag -a &lt;版本号&gt; -m &quot;&lt;备注信息&gt;&quot; 同时我们也可以像特定的commit添加标签，使用该commit对应的SHA值即可1git tag -a &lt;版本号&gt; &lt;SHA值&gt; -m &quot;&lt;备注信息&gt;&quot; 比如 git tag -a 1.0.0 0c3b62d -m &quot;Release Edition v1.0.0&quot; 就是为SHA为0c3b62d的这次提交打了1.0发行版的tag 删除标签删除本地标签1git tag -d &lt;版本号&gt; 删除远程仓库的标签1git push origin --delete &lt;版本号&gt; #新版本Git (&gt; v1.7.0) 推送标签推送所有标签1git push origin --tags 推送指定版本的标签1git push origin &lt;版本号&gt; 总结最后总结一下常用命令，方便查阅。123456789101112131415161718192021222324252627282930// 创建标签(本地)// 创建轻量标签git tag 1.0.0-light// 创建带备注标签(推荐)git tag -a 1.0.0 -m &quot;这是备注信息&quot;// 针对特定commit版本SHA创建标签git tag -a 1.0.0 0c3b62d -m &quot;这是备注信息&quot;// 查看标签// 打印所有标签git tag// 打印符合检索条件的标签git tag -l 1.*.*// 查看对应标签状态git checkout 1.0.0// 将本地标签发布到远程仓库// 发送所有git push origin --tags// 指定版本发送git push origin 1.0.0// 删除标签(本地)git tag -d 1.0.0// 删除远程仓库对应标签// Git版本 &gt; V1.7.0git push origin --delete 1.0.0// 旧版本Gitgit push origin :refs/tags/1.0.0 参考博客：使用Git添加Tag的方法]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo实现github+coding双线部署]]></title>
    <url>%2Fblog%2F2018%2F11%2F08%2FHexo%E5%AE%9E%E7%8E%B0github-coding%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Hexo是一个开源的静态博客框架，支持markdown文档，应用起来很方便而且有丰富的主题模板可供选择，是建立个性化的个人博客的不二之选，因为GitHub在国内访问速度较慢，因此选择Coding.从网上搜索的结果来看，很多人都认为github博客在国内的seo情况不太好，不被百度爬虫所青睐。一个比较好的方案是，同时将hexo博客部署到github和Coding上。 第一步：注册Coding账号第二步：Coding应用配置 第三步：配置SSH公钥我们要想生成SSH key，首先就得先安装 SSH，对于 Linux 和 Mac 系统，其默认是安装 SSH 的，而对于 Windows 系统，其默认是不安装 SSH 的，不过由于我们安装了 Git Bash，其也应该自带了 SSH. 可以通过在 Git Bash 中输入ssh命令，查看本机是否安装 SSH： 初次使用git的用户要使用git协议大概需要三个步骤：一、生成密钥对二、设置远程仓库（本文以github为例）上的公钥三、把git的 remote url 修改为git协议（以上两个步骤初次设置过以后，以后使用都不需要再次设置，此步骤视以后项目的remote url而定，如果以后其他项目的协议为https则需要此步骤）打开Hexo安装目录，右键git bash here点击打开你的id_rsa.pub文件，复制下里面的内容，然后登录进去你的coding； 第四步：初始化部署仓库 修改博客站点_config.yml 12345678# Deployment## Docs: https://hexo.io/docs/deployment.html#（修改coding的路径，实现coding及github同时部署）deploy:- type: git repository: github: git@github.com:wangrui15034005712/blog.git,master coding: https://git.dev.tencent.com/wangrui15034005712/demo.git,master 在gitbash上输入hexo clean 、hexo g再hexo d这样你的博客就被部署到Coding上了第五步：域名配置进入域名控制台，如有不理解之处可查看Hexo-Github搭建个人博客二 大功告成！ 个人博客：去年夏天参考博客：hexo+github打造个人博客系列之Coding托管（实现github+coding双线部署）]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客用自己的页面做首页]]></title>
    <url>%2Fblog%2F2018%2F11%2F07%2FHexo%E5%8D%9A%E5%AE%A2%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%81%9A%E9%A6%96%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[Hexo博客用自己的页面做首页。个人网站 去年夏天 欢迎大家的访问！ Demo地址：https://lastsummer.topDemo仓库：https://github.com/wangrui15034005712/wangrui15034005712.github.io那么接下来是教程，本教程的前提已经用hexo将博客搭建在 xxxxxx.github.io的repository上那么现在你要做的有以下几步 新建一个仓库 名字随便起 我起了 blog那么现在你有了一个空的仓库repository然后本地clone下按照提示初始化一个主master分支访问xxxxxx.github.io/blog成功即可 修改博客站点_config.yml1234567891011# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://xxxxxx.github.io/blog(改这里)root: /blog(改这里)permalink: :year/:month/:day/:title/permalink_defaults:deploy: type: git repository: https://github.com/xxxxxx/blog.git(改这里) branch: master 重新部署你的博客 在对应的文件下在gitbash上输入hexo clean 、hexo g再hexo d这样你的博客就被部署到https://xxxxxx.github.io/blog/上了 清空原来的仓库 现在原来那个xxxxxx.github.io的repository你就可以清空或者直接删除重新新建xxxxxx.github.io的repository（进入想要删除的仓库，点击setting 占到delete this repository 在弹窗里输入仓库名，确认即可）然后新建一个index.html，把你自定义页面的代码复制到里面就好了，然后可以通过&lt;a href=&quot;blog/&quot;&gt;&lt;/a&gt;跳转到你的博客界面了可以使用Demo进行配置，已在参考博客Demo代码中进行了优化 大功告成！ 个人博客：去年夏天参考博客：Hexo-用自己的页面做首页]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加返回顶部按钮]]></title>
    <url>%2Fblog%2F2018%2F11%2F06%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[Hexo博客添加返回顶部按钮。 返回顶部模块代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;div class=&quot;top gongyong&quot;&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;顶部&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;bottom gongyong&quot;&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;底部&lt;/a&gt;&lt;/div&gt;&lt;style&gt;body &#123; position:relative;&#125;.gongyong a &#123; width:50px; height:50px; background:#fff; color:#000; position:fixed; text-align:center; line-height:50px; right:2%; text-decoration:none; transition:all 0.5s; display:none;&#125;.top a &#123; top:70%;&#125;.bottom a &#123; top:80%;&#125;.gongyong a.hover &#123; background:#e14da0;&#125;&lt;/style&gt;&lt;script&gt;$(function() &#123; $(window).scroll(function() &#123; if ($(window).scrollTop() &gt;= 300) &#123; $(&apos;.gongyong a&apos;).fadeIn(600); &#125; else &#123; $(&apos;.gongyong a&apos;).fadeOut(600); &#125; &#125;); $(&apos;.gongyong a&apos;).hover(function() &#123; $(this).addClass(&apos;hover&apos;); &#125;, function() &#123; $(this).removeClass(&apos;hover&apos;); &#125;); $(&apos;.top a&apos;).click(function() &#123; $(&quot;html,body&quot;).animate(&#123; scrollTop: 0 &#125;, 500); &#125;); $(&apos;.bottom a&apos;).click(function() &#123; $(&quot;html,body&quot;).animate(&#123; scrollTop: $(document).height() &#125;, 500); &#125;);&#125;);&lt;/script&gt; 大功告成！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加评论功能]]></title>
    <url>%2Fblog%2F2018%2F11%2F05%2FHexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。 可用的评论系统大概有 来必力：https://livere.com （来自韩国，使用邮箱注册） 畅言： http://changyan.kuaizhan.com （安装需要备案号） Valine: https://github.com/xCss/Valine (用了下没效果，应该是我的主题没有集成Valine，支持Next） 综上，最终采用了来必力及畅言。 来必力注册官网 打开来必力官网 https://livere.com 安装及配置themes\hexo-theme-shana-master\layout\_partial\comments 下新建 livere.ejs(如不存在目录就新建即可) 把复制的内容粘贴进来；12345678910111213141516171819&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;&lt;%= theme.livere_uid %&gt;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;var refer = &quot;&#123;Permalink&#125;&quot;.replace(&quot;http://&quot;,&quot;&quot;); (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;);&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 在 themes\hexo-theme-shana-master\layout\_partial\article.ejs 中的内容底部添加如下内容：123&lt;% if (!index &amp;&amp; post.comments &amp;&amp; theme.livere.on)&#123; %&gt; &lt;%- partial(&apos;comments/livere&apos;) %&gt;&lt;% &#125; %&gt; 在主题themes\hexo-theme-shana-master\_config.yml添加内容如下(livere_uid就是data-uid)1234#来必力livere: on: true livere_uid: ############### 来必力就已经集成到自己的博客中啦！ 畅言注册官网 打开畅言官网 http://changyan.kuaizhan.com/ 安装及配置themes\hexo-theme-shana-master\layout\_partial\comments 下新建 changyan.ejs(如不存在目录就新建即可) 把复制的内容粘贴进来；12345678910111213141516171819202122232425&lt;!--PC和WAP自适应版 sid=&quot;请将此处替换为配置SourceID的语句&quot;--&gt;&lt;div id=&quot;SOHUCS&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; (function()&#123; var appid = &apos;修改成自己的畅言APP ID&apos;; var conf = &apos;修改成自己的畅言APP KEY&apos;; var width = window.innerWidth || document.documentElement.clientWidth; if (width &lt; 960) &#123; window.document.write(&apos;&lt;script id=&quot;changyan_mobile_js&quot; charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=&apos; + appid + &apos;&amp;conf=&apos; + conf + &apos;&quot;&gt;&lt;\/script&gt;&apos;); &#125; else &#123; var loadJs=function(d,a)&#123; var c=document.getElementsByTagName(&quot;head&quot;)[0]||document.head||document.documentElement; var b=document.createElement(&quot;script&quot;); b.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); b.setAttribute(&quot;charset&quot;,&quot;UTF-8&quot;); b.setAttribute(&quot;src&quot;,d); if(typeof a===&quot;function&quot;)&#123; if(window.attachEvent)&#123; b.onreadystatechange=function()&#123; var e=b.readyState;if(e===&quot;loaded&quot;||e===&quot;complete&quot;)&#123; b.onreadystatechange=null;a()&#125;&#125;&#125;else&#123;b.onload=a&#125;&#125;c.appendChild(b)&#125;; loadJs(&quot;https://changyan.sohu.com/upload/changyan.js&quot;, function()&#123;window.changyan.api.config(&#123;appid:appid,conf:conf&#125;)&#125;); &#125; &#125;)(); &lt;/script&gt; 在 themes\hexo-theme-shana-master\layout\_partial\article.ejs 中的内容底部添加如下内容：123&lt;% if (!index &amp;&amp; post.comments &amp;&amp; theme.changyan.on)&#123; %&gt; &lt;%- partial(&apos;comments/changyan&apos;) %&gt;&lt;% &#125; %&gt; 在主题themes\hexo-theme-shana-master\_config.yml添加内容如下123#畅言changyan: on: true 畅言就已经集成到自己的博客中啦！ 如果要修改来必力及畅言评论的样式，可以在官网进行相关配置：1、评论管理2、评论审核3、评论数据统计4、系统配置]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper安装和使用 windows环境]]></title>
    <url>%2Fblog%2F2018%2F10%2F30%2Fzookeeper%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-windows%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[简介1、ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。2、ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。3、ZooKeeper包含一个简单的原语集，提供Java和C的接口。4、ZooKeeper代码版本中，提供了分布式独享锁、选举、队列的接口，代码在zookeeper-3.4.12\src\recipes。其中分布锁和队列有Java和C两个版本，选举只有Java版本。 下载Apache官方最新版本为：3.4.12下载地址：http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz 安装解压到指定目录下 D:\dubbo\zookeeper-3.4.12修改zoo_sample.cfg 文件名(D:\dubbo\zookeeper-3.4.12\conf) 为 zoo.cfg主要修改一下日志位置，具体配置文件如下：1234567891011121314151617181920212223242526272829303132333435363738# The number of milliseconds of each tick#tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。 #默认情况下最小的会话超时时间为两倍的tickTime tickTime=2000# The number of ticks that the initial # synchronization phase can take #zookeeper集群中的包含多台server, 其中一台为leader, 集群中其余的server为follower. initLimit参数配置初始化连接时, #follower和leader之间的最长心跳时间. 此时该参数设置为5, 说明时间限制为5倍tickTime, 即5*2000=10000ms=10s. initLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgement#该参数配置leader和follower之间发送消息, 请求和应答的最大时间长度. 此时该参数设置为2, 说明时间限制为2倍tickTime, 即4000ms. syncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.#dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。 dataDir=D:\\dubbo\\zookeeper-3.4.12-1\\data#dataLogDir：顾名思义就是 Zookeeper 保存日志文件的目录 dataLogDir=D:\\dubbo\\zookeeper-3.4.12-1\\log# the port at which the clients will connect#clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。 clientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns：限制连接到 ZooKeeper 的客户端的数量 #maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1 配置文件简单解析1、tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。2、dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。3、dataLogDir：顾名思义就是 Zookeeper 保存日志文件的目录4、clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。 启动进入到bin目录，并且启动zkServer.cmd，这个脚本中会启动一个java进程(不可关闭，造成客户端无法访问)启动后jps可以看到QuorumPeerMain的进程也可以启动客户端连接一下OK，安装成功，很简单。 个人博客：去年夏天参考博客：zookeeper安装和使用 windows环境]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo入门---搭建一个最简单的Demo框架]]></title>
    <url>%2Fblog%2F2018%2F10%2F30%2FDubbo%E5%85%A5%E9%97%A8-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Demo%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Dubbo背景和简介Dubbo开始于电商系统，因此在这里先从电商系统的演变讲起。1.单一应用框架(ORM)当网站流量很小时，只需一个应用，将所有功能如下单支付等都部署在一起，以减少部署节点和成本。缺点：单一的系统架构，使得在开发过程中，占用的资源越来越多，而且随着流量的增加越来越难以维护。2.垂直应用框架(MVC)垂直应用架构解决了单一应用架构所面临的扩容问题，流量能够分散到各个子系统当中，且系统的体积可控，一定程度上降低了开发人员之间协同以及维护的成本，提升了开发效率。缺点：但是在垂直架构中相同逻辑代码需要不断的复制，不能复用。 3.分布式应用架构(RPC)当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心。4.流动计算架构(SOA)随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。 单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 此时，用于加速前端页面开发的 Web框架(MVC) 是关键。 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。 此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。 流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。 Dubbo是什么Dubbo是：一款分布式服务框架高性能和透明化的RPC远程服务调用方案SOA服务治理方案每天为2千多个服务提供大于30亿次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点以及别的公司的业务中。 Dubbo架构Provider: 暴露服务的服务提供方。Consumer: 调用远程服务的服务消费方。Registry: 服务注册与发现的注册中心。Monitor: 统计服务的调用次数和调用时间的监控中心。 调用流程0.服务容器负责启动，加载，运行服务提供者。1.服务提供者在启动时，向注册中心注册自己提供的服务。2.服务消费者在启动时，向注册中心订阅自己所需的服务。3.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo注册中心对于服务提供方，它需要发布服务，而且由于应用系统的复杂性，服务的数量、类型也不断膨胀；对于服务消费方，他关心如何获取到它所需要的服务，而面对复杂的应用系统，需要管理大量的服务调用。对于服务提供方和服务消费方来说，他们还有可能兼具这两种角色，即既需要提供服务，有需要消费服务。 通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。 Dubbo提供的注册中心有如下几种类型可供选择： Multicast注册中心 Zookeeper注册中心 Redis注册中心 Simple注册中心 Dubbo优缺点优点：1.透明化的远程方法调用&nbsp;&nbsp;&nbsp;&nbsp;像调用本地方法一样调用远程方法；只需简单配置，没有任何API侵入。2.软负载均衡及容错机制&nbsp;&nbsp;&nbsp;&nbsp;可在内网替代nginx lvs等硬件负载均衡器。3.服务注册中心自动注册 &amp; 配置管理&nbsp;&nbsp;&nbsp;&nbsp;不需要写死服务提供者地址，注册中心基于接口名自动查询提供者ip。&nbsp;&nbsp;&nbsp;&nbsp;使用类似zookeeper等分布式协调服务作为服务注册中心，可以将绝大部分项目配置移入zookeeper集群。4.服务接口监控与治理&nbsp;&nbsp;&nbsp;&nbsp;Dubbo-admin与Dubbo-monitor提供了完善的服务接口管理与监控功能，针对不同应用的不同接口，可以进行 多版本，多协议，多注册中心管理。缺点：只支持JAVA语言 Dubbo入门Demo了解了Dubbo以后，自然要搭建一个简单的Demo实现。本文采用Dubbo与Zookeeper、Spring框架的整合。主要步骤：1.安装Zookeeper,启动；2.创建MAVEN项目，构建Dubbo+Zookeeper+Spring实现的简单Demo；3.安装Dubbo-admin，实现监控。 Zookeeper介绍与安装本Demo中的Dubbo注册中心采用的是Zookeeper。为什么采用Zookeeper呢？Zookeeper是一个分布式的服务框架，是树型的目录服务的数据存储，能做到集群管理数据 ，这里能很好的作为Dubbo服务的注册中心。Dubbo能与Zookeeper做到集群部署，当提供者出现断电等异常停机时，Zookeeper注册中心能自动删除提供者信息，当提供者重启时，能自动恢复注册数据，以及订阅请求。具体的安装方法在此不一一叙述，可参考博文： zookeeper安装和使用 windows环境安装完成后，进入到bin目录，并且启动zkServer.cmd，这个脚本中会启动一个java进程：(注：需要先启动zookeeper后，后续dubbo demo代码运行才能使用zookeeper注册中心的功能，不可关闭) MAVEN项目 项目结构： 主要分三大模块： dubbo-api : 存放公共接口； dubbo-provider : 提供远程服务； dubbo-consumer : 调用远程服务； dubbo-consumer2 : 调用远程服务；具体的项目在此不一一叙述，整个项目的代码已经上传到我的github上https://github.com/wangrui15034005712/dubboTest.git 欢迎下载查看。运行项目，先确保provider已被运行后再启动consumer模块：当然，这只是一个模拟的项目，实际中有多提供者多消费者情况，比这要复杂的多，当然只有这样才能体现dubbo的特性。 Dubbo管理控制台介绍下载dubbo-admin，可自行根据网上介绍安装。大致做法就是将dubbo-admin中 的某个文件夹内容替换到tomcat的conf中，再运行tomcat即可。但我在实际操作中发现JDK8无法运行，后来找到一个JDK8可以实现的dubbo-admin版本，下载地址：链接: https://pan.baidu.com/s/1dxu1NctjLowFQylINul3gA 提取码: 5ci8 。把下载的dubbo-admin-2.6.0.war放置tomcat下的webapp中,访问localhost:8080/dubbo-admin-2.6.0即可访问管理控制台，账号密码默认都是root。 个人博客：去年夏天参考博客：Dubbo入门—搭建一个最简单的Demo框架]]></content>
      <categories>
        <category>SOA</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>Dubbo</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客实现站内搜索]]></title>
    <url>%2Fblog%2F2018%2F10%2F29%2FHexo%E5%8D%9A%E5%AE%A2%E5%AE%9E%E7%8E%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当博文慢慢变多的时候，标签和分类已经不能提供太大的作用，无法准确的定位到自己想要看的博客上去，所以添加一个本站内搜索功能是很有必要的，以 hexo-theme-shana-master 主题为例。Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。 基本思路123利用插件hexo-generator-search生成xml文件利用jQuery.ajax解析xml寻找所用主题对应文件修改 主要步骤安装插件直接在自己的博客文件夹下（我的是Hexo）点击鼠标右键选择Git Bash Here12cnpm install hexo-generator-search --savecnpm install hexo-generator-searchdb --save 修改站点配置文件博客Hexo下的_config.yml文件，进行编辑。123456#搜索search: path: search.xml #生成的路径 field: post format: html limit: 10000 编写站内搜索模块的代码(index.ejs)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;div id=&quot;site_search&quot; align=&apos;center&apos; style=&quot;margin:15px 0 0 0;&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;local-search-input&quot; name=&quot;q&quot; results=&quot;0&quot; placeholder=&quot;本站搜索&quot; style=&apos;width:180px;height:25px;&apos;/&gt; &lt;div id=&quot;local-search-result&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var searchFunc = function(path, search_id, content_id) &#123;&apos;use strict&apos;;$.ajax(&#123; url : path, dataType : &quot;xml&quot;, success : function(xmlResponse) &#123; // get the contents from search data var datas = $(&quot;entry&quot;, xmlResponse).map(function() &#123; return &#123; title : $(&quot;title&quot;, this).text(), content : $(&quot;content&quot;, this).text(), url : $(&quot;url&quot;, this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener(&apos;input&apos;, function() &#123; var str = &apos;&lt;ul class=\&quot;search-result-list\&quot;&gt;&apos;; var keywords = this.value.trim().toLowerCase().split( /[\s\-]+/); $resultContent.innerHTML = &quot;&quot;; if (this.value.trim().length &lt;= 0) &#123; return; &#125; // perform local searching datas.forEach(function(data) &#123; var isMatch = true; var content_index = []; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace( /&lt;[^&gt;]+&gt;/g, &quot;&quot;).toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty titles and contents if (data_title != &apos;&apos; &amp;&amp; data_content != &apos;&apos;) &#123; keywords.forEach(function(keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if (index_title &lt; 0 &amp;&amp; index_content &lt; 0) &#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; &#125; &#125;); &#125; // show search results if (isMatch) &#123; str += &quot;&lt;li&gt;&lt;a href=&apos;&quot; + data_url + &quot;&apos; class=&apos;search-result-title&apos;&gt;&quot; + data_title + &quot;&lt;/a&gt;&quot;; var content = data.content.trim().replace( /&lt;[^&gt;]+&gt;/g, &quot;&quot;); if (first_occur &gt;= 0) &#123; // cut out 100 characters var start = first_occur - 20; var end = first_occur + 80; if (start &lt; 0) &#123; start = 0; &#125; if (start == 0) &#123; end = 100; &#125; if (end &gt; content.length) &#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function(keyword) &#123; var regS = new RegExp(keyword, &quot;gi&quot;); match_content = match_content.replace( regS, &quot;&lt;em class=\&quot;search-keyword\&quot;&gt;&quot; + keyword + &quot;&lt;/em&gt;&quot;); &#125;); str += &quot;&lt;p class=\&quot;search-result\&quot;&gt;&quot; + match_content + &quot;...&lt;/p&gt;&quot; &#125; str += &quot;&lt;/li&gt;&quot;; &#125; &#125;); str += &quot;&lt;/ul&gt;&quot;; $resultContent.innerHTML = str; &#125;); &#125;&#125;);&#125;var search_path = &quot;&lt;%= config.search.searchpath %&gt;&quot;;if (search_path.length == 0) &#123; search_path = &quot;search.xml&quot;;&#125;var path = &quot;/&quot; + search_path;searchFunc(path, &apos;local-search-input&apos;, &apos;local-search-result&apos;);&lt;/script&gt; 大功告成！个人博客：去年夏天推荐博客：Hexo博客添加文章目录]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加文章目录]]></title>
    <url>%2Fblog%2F2018%2F10%2F29%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Hexo博客添加嵌入边栏的文章目录，以 hexo-theme-shana-master 主题为例。 第一步：编写文章目录模块的代码themes\hexo-theme-shana-master\layout\_partial 下新建 toc.ejs 输入如下内容：12345678910111213141516171819202122232425&lt;!-- 目录内容 --&gt;&lt;p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:none"&gt; &lt;span class="btn-bg"&gt;&lt;/span&gt; &lt;span class="btn-text"&gt;文章导航&lt;/span&gt;&lt;/p&gt;&lt;div id="toc-article" class="toc-article" &gt; &lt;span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();"&gt;×&lt;/span&gt; &lt;strong class="toc-title"&gt;文章目录&lt;/strong&gt; &lt;%- toc(post.content) %&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;function showToc()&#123; var toc_article = document.getElementById("toc-article"); var show_toc_btn = document.getElementById("show-toc-btn"); toc_article.setAttribute("style","display:block"); show_toc_btn.setAttribute("style","display:none");&#125;;function showBtn()&#123; var toc_article = document.getElementById("toc-article"); var show_toc_btn = document.getElementById("show-toc-btn"); toc_article.setAttribute("style","display:none"); show_toc_btn.setAttribute("style","display:block");&#125;;&lt;/script&gt;&lt;!-- 目录内容结束 --&gt; 第二步：编写文章目录模块的样式themes\hexo-theme-shana-master\source\css\_partial 下新建 toc.styl 输入如下内容：123456789101112131415161718192021222324&lt;style&gt;#container .show-toc-btn,#container .toc-article&#123;display:block&#125;.toc-article&#123;z-index:100;background:#fff;border:1px solid #ccc;max-width:250px;min-width:150px;max-height:500px;overflow-y:auto;-webkit-box-shadow:5px 5px 2px #ccc;box-shadow:5px 5px 2px #ccc;font-size:12px;padding:10px;position:fixed;right:35px;top:129px&#125;.toc-article .toc-close&#123;font-weight:700;font-size:20px;cursor:pointer;float:right;color:#ccc&#125;.toc-article .toc-close:hover&#123;color:#000&#125;.toc-article .toc&#123;font-size:12px;padding:0;line-height:20px&#125;.toc-article .toc .toc-number&#123;color:#333&#125;.toc-article .toc .toc-text:hover&#123;text-decoration:underline;color:#2a6496&#125;.toc-article li&#123;list-style-type:none&#125;.toc-article .toc-level-1&#123;margin:4px 0&#125;.toc-article .toc-child&#123;&#125;@-moz-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-webkit-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-o-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;.show-toc-btn&#123;display:none;z-index:10;width:30px;min-height:14px;overflow:hidden;padding:4px 6px 8px 5px;border:1px solid #ddd;border-right:none;position:fixed;right:40px;text-align:center;background-color:#f9f9f9&#125;.show-toc-btn .btn-bg&#123;margin-top:2px;display:block;width:16px;height:14px;background:url(http://7xtawy.com1.z0.glb.clouddn.com/show.png) no-repeat;-webkit-background-size:100%;-moz-background-size:100%;background-size:100%&#125;.show-toc-btn .btn-text&#123;color:#999;font-size:12px&#125;.show-toc-btn:hover&#123;cursor:pointer&#125;.show-toc-btn:hover .btn-bg&#123;background-position:0 -16px&#125;.show-toc-btn:hover .btn-text&#123;font-size:12px;color:#ea8010&#125;.toc-article li ol, .toc-article li ul &#123;margin-left: 30px;&#125;.toc-article ol, .toc-article ul &#123;margin: 10px 0;&#125;&lt;/style&gt; 最后，记得在 toc.styl 中添加 @import _partial/toc 第三步：将文章目录模块整合到文章中在 themes\hexo-theme-shana-master\layout\_partial\article.ejs 中的 &lt;article&gt; &lt;/article&gt; 标签内添加如下内容：12345&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt; &lt;%- partial(&apos;toc&apos;) %&gt; &lt;%- post.content %&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt; 若想要文章显示目录，在每篇文章开头加入：toc: true 大功告成！个人博客：去年夏天推荐博客：Hexo博客添加文章目录参考博客：Hexo+yilia主题实现文章目录和添加视频]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客用Leancloud统计文章阅读量]]></title>
    <url>%2Fblog%2F2018%2F10%2F26%2FHexo%E5%8D%9A%E5%AE%A2%E7%94%A8Leancloud%E7%BB%9F%E8%AE%A1%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Hexo博客用Leancloud统计文章阅读量，以 hexo-theme-shana-master 主题为例。 第一步：注册LeanCloud账号(GitHub)第二步：LeanCloud应用配置 第三步：Hexo主题配置打开博客根目录/themes/next/下的_config.yml，查找leancloud，填写复制来的App ID和App Key，重新生成、步署博客即可正常统计文章阅读量。12345# leadcloud访问次数统计leancloud_visitors: enable: true app_id: Your AppId app_key: Your AppKey 第四步：域名附赠说明因为AppID以及AppKey是暴露在外的，为了确保只用于我们自己的博客，建议设置Web安全域名，填入自己的博客域名。1.记录文章访问量的唯一标识符是文章的发布日期和文章的标题，因此请确保这两个数值组合的唯一性，如果更改了这两个数值，会造成文章阅读数值的清零重计。 2.初始的文章统计量显示为0。在配置好阅读量统计服务之后，第一次打开博文时，会自动向服务器发送数据，该数据会被记录在对应的应用的Counter表中。 3.修改Counter表中的time字段的数值，可以修改文章的访问量。双击具体的数值，修改之后回车即可保存。 大功告成！个人博客：去年夏天推荐博客：NexT主题用Leancloud统计文章阅读量参考博客：NexT主题下，用Leancloud统计文章阅读量]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Leancloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加打赏功能]]></title>
    <url>%2Fblog%2F2018%2F10%2F25%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[基本思路是将微信和支付宝的收款二维码放到每篇文章的最后，打赏的时候扫下二维码就可以了。以 hexo-theme-shana-master 主题为例： 第一步：编写打赏模块的代码themes\hexo-theme-shana-master\layout\_partial 下新建 donate.ejs 输入如下内容：123456789101112131415161718192021222324252627&lt;! -- 添加捐赠图标 --&gt; &lt;div align='center' style='margin-top:80px;'&gt; &lt;div id='donate_board' class="donate_bar"&gt; &lt;a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"&gt;&lt;/a&gt; &lt;span class="donate_txt"&gt; &amp;uarr;&lt;br&gt; &lt;%=theme.donate_message%&gt; &lt;/span&gt; &lt;/div&gt; &lt;div id="donate_guide" class="donate_bar hidden" &gt; &lt;!-- 支付宝打赏图案 --&gt; &lt;img src="/photos/donate/zhifubao.jpg" alt="支付宝打赏"&gt; &lt;!-- 微信打赏图案 --&gt; &lt;img src="/photos/donate/weixin.png" alt="微信打赏"&gt; &lt;/div&gt; &lt;script&gt; document.getElementById('btn_donate').onclick = function()&#123; $('#donate_board').addClass('hidden'); $('#donate_guide').removeClass('hidden'); &#125; document.getElementById('donate_guide').onclick = function()&#123; $('#donate_guide').addClass('hidden'); $('#donate_board').removeClass('hidden'); &#125; &lt;/script&gt; &lt;/div&gt;&lt;! -- 添加捐赠图标 --&gt; 第二步： 编写打赏模块的样式themes\hexo-theme-shana-master\source\css\_partial 下新建 donate.styl 输入如下内容：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.donate_bar &#123; text-align: center; margin-top: 5%&#125;.donate_bar a.btn_donate &#123; display: inline-block; width: 82px; height: 82px; margin-left: auto; margin-right: auto; background: url(http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif)no-repeat; -webkit-transition: background 0s; -moz-transition: background 0s; -o-transition: background 0s; -ms-transition: background 0s; transition: background 0s&#125;.donate_bar a.btn_donate:hover &#123; background-position: 0 -82px&#125;.donate_bar .donate_txt &#123; display: block; color: #9d9d9d; font: 14px/2 "Microsoft Yahei"&#125;.donate_bar.hidden&#123; display: none&#125;.post-donate&#123; margin-top: 80px;&#125;#donate_guide&#123; height: 210px; width: 420px; margin: 0 auto;&#125;#donate_guide img&#123; height: 200px; height: 200px;&#125; 最后，记得在 style.styl 中添加 @import _partial/donate 第三步： 讲打赏模块整合到文章中在 themes\hexo-theme-shana-master\layout\_partial\article.ejs 中的 &lt;article&gt; &lt;/article&gt; 标签内添加如下内容：123&lt;% if (!index &amp;&amp; theme.donate &amp;&amp; post.donate)&#123; %&gt; &lt;%- partial(&apos;donate/donate&apos;) %&gt;&lt;% &#125; %&gt; 第四步： 编写配置文件我们在\themes\hexo-theme-shana-master\_config.yml主题文件中关闭和打开打赏功能，还可以自定义设置打赏文案。1234#是否开启打赏功能donate: true#打赏文案donate_message: 欣赏此文？求鼓励，求支持！ 如果我们要针对某一篇文章关闭打赏功能的话，只需要在该篇文章上添加 donate: false 代码即可。 大功告成！个人博客：去年夏天推荐博客：Hexo博客添加打赏功能参考博客：Hexo 博客添加打赏功能]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加图片音乐及视频]]></title>
    <url>%2Fblog%2F2018%2F10%2F23%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E9%9F%B3%E4%B9%90%E5%8F%8A%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[Hexo博客添加图片音乐及视频。 插入外部链接图片1![“图片描述”](“图片地址”) 添加本地图片在\hexo\source目录下新建文件夹，命名为images或者其他你喜欢的名字，然后编辑你的md博文，插入下面的代码样式：1![“图片描述”](/images/你的图片名字.JPG) 插入音乐1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=660 height=86 src="//music.163.com/outchain/player?type=2&amp;id=1306515028&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt; 插入视频1&lt;iframe height=498 width=660 src='//player.youku.com/embed/XMzgyNTI5NTY1Mg==' frameborder=0 'allowfullscreen'&gt;&lt;/iframe&gt; 个人博客：去年夏天相关链接: 去年夏天参考博客：hexo博客添加图片，音乐，视频]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Github搭建个人博客二]]></title>
    <url>%2Fblog%2F2018%2F10%2F19%2FHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[本文主要介绍了域名解析绑定及SSH部署博客到Github。 Github绑定域名相关步骤Github注册访问Github官方地址 Github输入用户名、电子邮箱、密码,然后点击注册按钮.–&gt;之后验证邮箱（进入自己邮箱进行验证）在github上面创建项目(借用github服务器)静态网站在git命令框中安装git插件(cnpm install hexo-deployer-git –save)打开Hexo安装目录，编辑_config.yml文件1234deploy: type: git repository: git@github.com:wangrui15034005712/wangrui15034005712.github.io.git branch: master Git使用ssh密钥git支持https和git两种传输协议，github分享链接时会有两种协议可选：我们要想生成SSH key，首先就得先安装 SSH，对于 Linux 和 Mac 系统，其默认是安装 SSH 的，而对于 Windows 系统，其默认是不安装 SSH 的，不过由于我们安装了 Git Bash，其也应该自带了 SSH. 可以通过在 Git Bash 中输入ssh命令，查看本机是否安装 SSH：初次使用git的用户要使用git协议大概需要三个步骤：一、生成密钥对二、设置远程仓库（本文以github为例）上的公钥三、把git的 remote url 修改为git协议（以上两个步骤初次设置过以后，以后使用都不需要再次设置，此步骤视以后项目的remote url而定，如果以后其他项目的协议为https则需要此步骤）打开Hexo安装目录，右键git bash here点击打开你的id_rsa.pub文件，复制下里面的内容，然后登录进去你的github；至此，Github步骤结束。 域名购买解析国内可以去几个大型的域名商去购买即可，直接搜域名购买，搜索引擎前几的都可以(万网、百度云、腾讯云、新网、西部数码、阿里云)，如果国外的可以去godday、name等站点去购买访问阿里云官方地址 阿里云输入会员名、手机号、密码,然后点击注册按钮.–&gt;之后验证手机(可通过淘宝或者支付宝进行登陆)至此，域名解析步骤结束，我们可以通过自己的域名进行访问了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Github搭建个人博客]]></title>
    <url>%2Fblog%2F2018%2F10%2F15%2FHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[首先呢，先说一下吧，这是本人第一次写博客，也是在大学生时代的一个想法，现在终于实现了。花了几天的时间，研究了一下，颇有收获，而我在找资料的过程中，都是这个博客找点那个博客找点，都没有一个博客的教程是很详细且到位的，哎，醉了，感谢你们一直看到这里听我在这里碎碎念，最后啰嗦一句，有什么问题，及时下方评论(不是私信)，因为我几乎每天登陆博客，所以看到后会及时回复大家的。环境配置： 电脑系统为window 10专业版，64位，Nodejs, Github, Hexo, livere, Leancloud, ShareSDK, Dalao。 相关步骤安装Node.js和配置好Node.js环境,我的版本10.11.01、访问官方地址 https://nodejs.org/en/download/ 根据自己的系统进行下载。2、检测是否安装成功：点击开始-运行-cmd（win+R），打开dos，输入“node –version”检查Nodejs版本；输入“npm –version”检查npm版本：3、这里我们要分两步，第一步修改NPM的缓存目录和全局目录路径，将对应的模块目录改到D盘nodejs的安装目录，第二步是配置npm和nodejs的环境变量，这样nodejs才能正确地调用对应的模块。我们先来做第一步，在nodejs目录下创建两个目录，分别是node_cache和node_global，这是用来放安装过程的缓存文件以及最终的模块配置位置。配置完成后，执行下面这两个命令：npm config set prefix “D:\Program Files (x86)\nodejs\node_global”npm config set cache “D:\Program Files (x86)\nodejs\node_cache”将npm的全局模块目录和缓存目录配置到我们刚才创建的那两个目录：然后我们来配置npm的环境变量和nodejs的环境变量。在计算机图标上点右键，选属性，然后点击高级系统配置，弹出来的新窗口右下角有个环境路径，点击去，就能看到环境路径的配置界面，我们点击新建。然后在弹出来的窗口里，变量名填：NODE_PATH变量值填：D:\Program Files (x86)\nodejs\node_global\node_modules由于npm的镜像是国外的，为了加快下载速度，可以通过国内淘宝镜像来下载，所以采用cnpm，当然也可以不采用cnpm，直接把镜像指向淘宝镜像，接下来我说下这两种方式：(1)直接指定registry为淘宝镜像：npm config set registry https://registry.npm.taobao.org(2)安装cnpm：npm install -g cnpm –registry=https://registry.npm.taobao.org 输入上述命令即可安装，另外要注意的是，安装完后，输入cnpm -v进行检测。至此，node.js安装步骤完毕。 安装Git,我的版本2.14.21、访问官方地址 https://git-scm.com/download/win windows64版本检测是否安装成功：点击开始-运行-cmd（win+R），打开dos，输入“git –version”检查git版本；你需要运行命令来配置你的用户名和邮箱：12git config --global user.name "wangrui"git config --global user.email "150340057121990@163.com" 注意：（引号内请输入你自己设置的名字，和你自己的邮箱）此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱至此，安装git步骤结束。 安装hexo首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用)在Hexo文件夹中右键，单击Git Bash Here，git终端开启。由于已经使用了淘宝镜像cnpm，直接使用即可在git命令框中安装Hexo(cnpm install -g hexo)在git命令框中git+hexo模块(cnpm install hexo-server –save)hexo基本命令hexo服务启动 hexo server 简写 hexo shexo删除文件 hexo clean 简写 hexo cleanhexo生成文件 hexo generate 简写 hexo ghexo部署文件 hexo deploy 简写 hexo d浏览器输入http://localhost:4000 按理来说应该会出现本地访问页面注意：访问本地页面的时候hexo server 不可以按ctrl+c停止服务，否则会报404本地测试:至此，安装hexo步骤结束,博客基本搭建完成！随后我会陆续更新自己的博客，评论，打赏，分类，标签，分享，域名绑定，照片墙等等陆续上线！个人博客：去年夏天推荐博客：Hexo-Github域名绑定及SSH密钥配置参考博客：hexo+github搭建个人博客(超详细教程)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Nodejs</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2018%2F10%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>心情</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
